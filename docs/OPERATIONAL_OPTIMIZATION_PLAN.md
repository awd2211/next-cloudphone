# è¿è¥ä¼˜åŒ–å®æ–½æ–¹æ¡ˆ

> åŸºäºäº‘æ‰‹æœºå¹³å°ç°æœ‰æ¶æ„çš„è¿è¥ä¼˜åŒ–è¯¦ç»†å®æ–½è®¡åˆ’
> ç”Ÿæˆæ—¥æœŸ: 2025-11-05

## ç›®å½•

1. [å¥åº·åº¦è¯„åˆ†ä¸é¢„è­¦ç³»ç»Ÿ](#1-å¥åº·åº¦è¯„åˆ†ä¸é¢„è­¦ç³»ç»Ÿ)
2. [æ™ºèƒ½è¿ç»´è‡ªåŠ¨åŒ–å¢å¼º](#2-æ™ºèƒ½è¿ç»´è‡ªåŠ¨åŒ–å¢å¼º)
3. [æˆæœ¬ä¸å®¹é‡ä¼˜åŒ–ç³»ç»Ÿ](#3-æˆæœ¬ä¸å®¹é‡ä¼˜åŒ–ç³»ç»Ÿ)
4. [å·¥å•ä¸æ”¯æŒç³»ç»Ÿä¼˜åŒ–](#4-å·¥å•ä¸æ”¯æŒç³»ç»Ÿä¼˜åŒ–)
5. [å®æ–½è·¯çº¿å›¾](#5-å®æ–½è·¯çº¿å›¾)

---

## 1. å¥åº·åº¦è¯„åˆ†ä¸é¢„è­¦ç³»ç»Ÿ

### 1.1 ç³»ç»Ÿç›®æ ‡

**æ ¸å¿ƒç›®æ ‡**ï¼šé€šè¿‡å¤šç»´åº¦æŒ‡æ ‡ç›‘æ§ç”¨æˆ·ä½¿ç”¨å¥åº·åº¦ï¼Œæå‰è¯†åˆ«æµå¤±é£é™©ï¼Œä¸»åŠ¨å¹²é¢„æå‡ç•™å­˜ç‡ã€‚

**é¢„æœŸæ•ˆæœ**ï¼š
- æµå¤±é¢„è­¦å‡†ç¡®ç‡ > 85%
- æå‰é¢„è­¦æ—¶é—´ 7-14 å¤©
- ç”¨æˆ·ç•™å­˜ç‡æå‡ 15-25%

### 1.2 æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Health Score System                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Data        â”‚  â”‚ Score        â”‚  â”‚ Alert &         â”‚   â”‚
â”‚  â”‚ Collection  â”‚â”€â–¶â”‚ Calculation  â”‚â”€â–¶â”‚ Intervention    â”‚   â”‚
â”‚  â”‚             â”‚  â”‚              â”‚  â”‚                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚         â”‚                  â”‚                   â”‚            â”‚
â”‚         â–¼                  â–¼                   â–¼            â”‚
â”‚  [Metrics API]    [Health Service]    [Notification]       â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.3 å¥åº·åº¦è¯„åˆ†æ¨¡å‹

#### è¯„åˆ†ç»´åº¦ï¼ˆæ€»åˆ† 100 åˆ†ï¼‰

| ç»´åº¦ | æƒé‡ | æŒ‡æ ‡ | è¯„åˆ†è§„åˆ™ |
|------|------|------|---------|
| **æ´»è·ƒåº¦** | 35% | â€¢ ç™»å½•é¢‘ç‡<br>â€¢ è®¾å¤‡ä½¿ç”¨æ—¶é•¿<br>â€¢ API è°ƒç”¨é¢‘ç‡ | â€¢ æ¯æ—¥ç™»å½•: +10åˆ†<br>â€¢ è®¾å¤‡è¿è¡Œ >4h/å¤©: +15åˆ†<br>â€¢ API æ´»è·ƒ: +10åˆ† |
| **èµ„æºåˆ©ç”¨ç‡** | 25% | â€¢ è®¾å¤‡åˆ©ç”¨ç‡<br>â€¢ é…é¢ä½¿ç”¨ç‡<br>â€¢ åŠŸèƒ½è¦†ç›–åº¦ | â€¢ åˆ©ç”¨ç‡ 70-90%: +15åˆ†<br>â€¢ å¤šåŠŸèƒ½ä½¿ç”¨: +10åˆ† |
| **ç¨³å®šæ€§** | 20% | â€¢ é”™è¯¯ç‡<br>â€¢ å·¥å•æäº¤ç‡<br>â€¢ æ”¯ä»˜æˆåŠŸç‡ | â€¢ é”™è¯¯ç‡ <5%: +10åˆ†<br>â€¢ æ— å·¥å•: +10åˆ† |
| **å¢é•¿æ€§** | 15% | â€¢ è®¾å¤‡å¢é•¿è¶‹åŠ¿<br>â€¢ æ¶ˆè´¹å¢é•¿è¶‹åŠ¿<br>â€¢ å¥—é¤å‡çº§ | â€¢ æ­£å¢é•¿: +10åˆ†<br>â€¢ å·²å‡çº§: +5åˆ† |
| **äº’åŠ¨æ€§** | 5% | â€¢ æ–‡æ¡£é˜…è¯»<br>â€¢ ç¤¾åŒºå‚ä¸<br>â€¢ åé¦ˆæäº¤ | â€¢ æœ‰äº’åŠ¨: +5åˆ† |

#### å¥åº·åº¦ç­‰çº§åˆ’åˆ†

```typescript
enum HealthLevel {
  EXCELLENT = 'excellent',    // 90-100 åˆ†ï¼šä¼˜ç§€ç”¨æˆ·
  GOOD = 'good',             // 75-89 åˆ†ï¼šå¥åº·ç”¨æˆ·
  FAIR = 'fair',             // 60-74 åˆ†ï¼šè§‚å¯Ÿç”¨æˆ·
  POOR = 'poor',             // 40-59 åˆ†ï¼šé¢„è­¦ç”¨æˆ·
  CRITICAL = 'critical'      // 0-39 åˆ†ï¼šé«˜å±ç”¨æˆ·
}
```

### 1.4 æŠ€æœ¯å®ç°æ–¹æ¡ˆ

#### 1.4.1 æ–°å¢æœåŠ¡æ¨¡å—

åœ¨ **user-service** ä¸­æ–°å¢å¥åº·åº¦æ¨¡å—ï¼š

```
backend/user-service/src/health-score/
â”œâ”€â”€ health-score.module.ts
â”œâ”€â”€ health-score.service.ts
â”œâ”€â”€ health-score.controller.ts
â”œâ”€â”€ health-score.scheduler.ts
â”œâ”€â”€ entities/
â”‚   â”œâ”€â”€ user-health-score.entity.ts
â”‚   â””â”€â”€ health-score-history.entity.ts
â”œâ”€â”€ dto/
â”‚   â”œâ”€â”€ health-score.dto.ts
â”‚   â””â”€â”€ health-alert.dto.ts
â””â”€â”€ calculators/
    â”œâ”€â”€ activity-calculator.ts
    â”œâ”€â”€ utilization-calculator.ts
    â”œâ”€â”€ stability-calculator.ts
    â”œâ”€â”€ growth-calculator.ts
    â””â”€â”€ engagement-calculator.ts
```

#### 1.4.2 æ•°æ®åº“è¡¨è®¾è®¡

```sql
-- ç”¨æˆ·å¥åº·åº¦è¯„åˆ†è¡¨
CREATE TABLE user_health_scores (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    score INTEGER NOT NULL CHECK (score >= 0 AND score <= 100),
    level VARCHAR(20) NOT NULL,

    -- åˆ†ç»´åº¦å¾—åˆ†
    activity_score INTEGER,
    utilization_score INTEGER,
    stability_score INTEGER,
    growth_score INTEGER,
    engagement_score INTEGER,

    -- è¯¦ç»†æŒ‡æ ‡
    metrics JSONB,

    -- é£é™©æ ‡è®°
    churn_risk BOOLEAN DEFAULT FALSE,
    risk_factors TEXT[],

    -- å¹²é¢„è®°å½•
    intervention_status VARCHAR(50),
    last_intervention_at TIMESTAMP,

    calculated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- å¥åº·åº¦å†å²è®°å½•è¡¨
CREATE TABLE health_score_histories (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id),
    score INTEGER NOT NULL,
    level VARCHAR(20) NOT NULL,
    metrics JSONB,
    recorded_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- ç´¢å¼•
CREATE INDEX idx_health_scores_user_id ON user_health_scores(user_id);
CREATE INDEX idx_health_scores_level ON user_health_scores(level);
CREATE INDEX idx_health_scores_churn_risk ON user_health_scores(churn_risk) WHERE churn_risk = TRUE;
CREATE INDEX idx_health_histories_user_time ON health_score_histories(user_id, recorded_at DESC);
```

#### 1.4.3 æ ¸å¿ƒæœåŠ¡ä»£ç æ¡†æ¶

```typescript
// backend/user-service/src/health-score/health-score.service.ts

import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Cron, CronExpression } from '@nestjs/schedule';
import { EventBusService } from '@cloudphone/shared';
import { UserHealthScore } from './entities/user-health-score.entity';
import {
  ActivityCalculator,
  UtilizationCalculator,
  StabilityCalculator,
  GrowthCalculator,
  EngagementCalculator
} from './calculators';

@Injectable()
export class HealthScoreService {
  private readonly logger = new Logger(HealthScoreService.name);

  constructor(
    @InjectRepository(UserHealthScore)
    private healthScoreRepo: Repository<UserHealthScore>,
    private activityCalc: ActivityCalculator,
    private utilizationCalc: UtilizationCalculator,
    private stabilityCalc: StabilityCalculator,
    private growthCalc: GrowthCalculator,
    private engagementCalc: EngagementCalculator,
    private eventBus: EventBusService,
  ) {}

  /**
   * è®¡ç®—ç”¨æˆ·å¥åº·åº¦è¯„åˆ†
   */
  async calculateUserHealthScore(userId: string): Promise<UserHealthScore> {
    this.logger.log(`è®¡ç®—ç”¨æˆ· ${userId} çš„å¥åº·åº¦è¯„åˆ†`);

    // è·å–å„ç»´åº¦å¾—åˆ†
    const activityScore = await this.activityCalc.calculate(userId);
    const utilizationScore = await this.utilizationCalc.calculate(userId);
    const stabilityScore = await this.stabilityCalc.calculate(userId);
    const growthScore = await this.growthCalc.calculate(userId);
    const engagementScore = await this.engagementCalc.calculate(userId);

    // åŠ æƒè®¡ç®—æ€»åˆ†
    const totalScore = Math.round(
      activityScore * 0.35 +
      utilizationScore * 0.25 +
      stabilityScore * 0.20 +
      growthScore * 0.15 +
      engagementScore * 0.05
    );

    // ç¡®å®šå¥åº·åº¦ç­‰çº§
    const level = this.determineHealthLevel(totalScore);

    // è¯†åˆ«é£é™©å› ç´ 
    const riskFactors = this.identifyRiskFactors({
      activityScore,
      utilizationScore,
      stabilityScore,
      growthScore,
      engagementScore,
    });

    const churnRisk = level === HealthLevel.POOR || level === HealthLevel.CRITICAL;

    // ä¿å­˜è¯„åˆ†
    const healthScore = await this.healthScoreRepo.save({
      userId,
      score: totalScore,
      level,
      activityScore,
      utilizationScore,
      stabilityScore,
      growthScore,
      engagementScore,
      churnRisk,
      riskFactors,
      metrics: {
        activityScore,
        utilizationScore,
        stabilityScore,
        growthScore,
        engagementScore,
      },
      calculatedAt: new Date(),
    });

    // å¦‚æœæœ‰æµå¤±é£é™©ï¼Œè§¦å‘å‘Šè­¦
    if (churnRisk) {
      await this.triggerChurnAlert(healthScore);
    }

    return healthScore;
  }

  /**
   * ç¡®å®šå¥åº·åº¦ç­‰çº§
   */
  private determineHealthLevel(score: number): HealthLevel {
    if (score >= 90) return HealthLevel.EXCELLENT;
    if (score >= 75) return HealthLevel.GOOD;
    if (score >= 60) return HealthLevel.FAIR;
    if (score >= 40) return HealthLevel.POOR;
    return HealthLevel.CRITICAL;
  }

  /**
   * è¯†åˆ«é£é™©å› ç´ 
   */
  private identifyRiskFactors(scores: {
    activityScore: number;
    utilizationScore: number;
    stabilityScore: number;
    growthScore: number;
    engagementScore: number;
  }): string[] {
    const risks: string[] = [];

    if (scores.activityScore < 20) {
      risks.push('æ´»è·ƒåº¦ä½ï¼šè¿‘æœŸç™»å½•å’Œä½¿ç”¨é¢‘ç‡ä¸‹é™');
    }
    if (scores.utilizationScore < 15) {
      risks.push('èµ„æºåˆ©ç”¨ç‡ä½ï¼šè®¾å¤‡å’Œé…é¢æœªå……åˆ†ä½¿ç”¨');
    }
    if (scores.stabilityScore < 10) {
      risks.push('ç¨³å®šæ€§å·®ï¼šé”™è¯¯ç‡é«˜æˆ–é¢‘ç¹æäº¤å·¥å•');
    }
    if (scores.growthScore < 5) {
      risks.push('å¢é•¿åœæ»ï¼šæœªè§è®¾å¤‡æˆ–æ¶ˆè´¹å¢é•¿');
    }
    if (scores.engagementScore < 3) {
      risks.push('äº’åŠ¨ç¼ºå¤±ï¼šæœªå‚ä¸ç¤¾åŒºæˆ–åé¦ˆ');
    }

    return risks;
  }

  /**
   * è§¦å‘æµå¤±é£é™©å‘Šè­¦
   */
  private async triggerChurnAlert(healthScore: UserHealthScore): Promise<void> {
    this.logger.warn(
      `ç”¨æˆ· ${healthScore.userId} å­˜åœ¨æµå¤±é£é™©ï¼Œè¯„åˆ†: ${healthScore.score}ï¼Œç­‰çº§: ${healthScore.level}`
    );

    // å‘å¸ƒæµå¤±é£é™©äº‹ä»¶
    await this.eventBus.publishUserEvent('churn_risk_detected', {
      userId: healthScore.userId,
      score: healthScore.score,
      level: healthScore.level,
      riskFactors: healthScore.riskFactors,
      timestamp: new Date().toISOString(),
    });

    // è§¦å‘è‡ªåŠ¨å¹²é¢„æµç¨‹
    await this.triggerIntervention(healthScore);
  }

  /**
   * è§¦å‘è‡ªåŠ¨å¹²é¢„
   */
  private async triggerIntervention(healthScore: UserHealthScore): Promise<void> {
    // æ ¹æ®é£é™©ç­‰çº§å’Œå› ç´ ï¼Œé€‰æ‹©å¹²é¢„ç­–ç•¥
    const interventionStrategies = this.selectInterventionStrategies(healthScore);

    for (const strategy of interventionStrategies) {
      await this.executeIntervention(healthScore.userId, strategy);
    }

    // æ›´æ–°å¹²é¢„çŠ¶æ€
    await this.healthScoreRepo.update(healthScore.id, {
      interventionStatus: 'in_progress',
      lastInterventionAt: new Date(),
    });
  }

  /**
   * é€‰æ‹©å¹²é¢„ç­–ç•¥
   */
  private selectInterventionStrategies(healthScore: UserHealthScore): InterventionStrategy[] {
    const strategies: InterventionStrategy[] = [];

    // æ ¹æ®é£é™©å› ç´ é€‰æ‹©å¯¹åº”ç­–ç•¥
    if (healthScore.riskFactors.some(r => r.includes('æ´»è·ƒåº¦ä½'))) {
      strategies.push({
        type: 'engagement_boost',
        action: 'send_feature_highlight_email',
        params: { features: ['æ–°åŠŸèƒ½', 'ä¼˜æƒ æ´»åŠ¨'] },
      });
    }

    if (healthScore.riskFactors.some(r => r.includes('èµ„æºåˆ©ç”¨ç‡ä½'))) {
      strategies.push({
        type: 'usage_optimization',
        action: 'send_optimization_tips',
        params: { tips: ['èµ„æºé…ç½®å»ºè®®', 'æœ€ä½³å®è·µ'] },
      });
    }

    if (healthScore.riskFactors.some(r => r.includes('ç¨³å®šæ€§å·®'))) {
      strategies.push({
        type: 'support_outreach',
        action: 'assign_customer_success_manager',
        params: { priority: 'high' },
      });
    }

    if (healthScore.level === HealthLevel.CRITICAL) {
      strategies.push({
        type: 'retention_offer',
        action: 'send_discount_coupon',
        params: { discount: '20%', validDays: 7 },
      });
    }

    return strategies;
  }

  /**
   * æ‰§è¡Œå¹²é¢„æªæ–½
   */
  private async executeIntervention(
    userId: string,
    strategy: InterventionStrategy
  ): Promise<void> {
    this.logger.log(
      `æ‰§è¡Œå¹²é¢„ç­–ç•¥ [${strategy.type}] for user ${userId}: ${strategy.action}`
    );

    // å‘å¸ƒå¹²é¢„äº‹ä»¶ï¼Œç”±notification-serviceå¤„ç†
    await this.eventBus.publish('cloudphone.events', 'user.intervention_triggered', {
      userId,
      strategyType: strategy.type,
      action: strategy.action,
      params: strategy.params,
      timestamp: new Date().toISOString(),
    });
  }

  /**
   * å®šæ—¶ä»»åŠ¡ï¼šæ¯æ—¥å‡Œæ™¨2ç‚¹è®¡ç®—æ‰€æœ‰ç”¨æˆ·å¥åº·åº¦
   */
  @Cron('0 2 * * *')
  async calculateAllUsersHealthScore(): Promise<void> {
    this.logger.log('å¼€å§‹æ‰¹é‡è®¡ç®—ç”¨æˆ·å¥åº·åº¦è¯„åˆ†');

    // è·å–æ‰€æœ‰æ´»è·ƒç”¨æˆ·
    const activeUsers = await this.getActiveUsers();

    let processed = 0;
    let errors = 0;

    for (const user of activeUsers) {
      try {
        await this.calculateUserHealthScore(user.id);
        processed++;
      } catch (error) {
        this.logger.error(
          `è®¡ç®—ç”¨æˆ· ${user.id} å¥åº·åº¦å¤±è´¥: ${error.message}`,
          error.stack
        );
        errors++;
      }
    }

    this.logger.log(
      `å¥åº·åº¦è¯„åˆ†è®¡ç®—å®Œæˆ: æˆåŠŸ ${processed}, å¤±è´¥ ${errors}, æ€»è®¡ ${activeUsers.length}`
    );
  }

  /**
   * è·å–ç”¨æˆ·å¥åº·åº¦è¶‹åŠ¿
   */
  async getUserHealthTrend(
    userId: string,
    days: number = 30
  ): Promise<HealthScoreTrend> {
    const histories = await this.healthScoreRepo
      .createQueryBuilder('h')
      .where('h.userId = :userId', { userId })
      .andWhere('h.calculatedAt >= NOW() - INTERVAL :days DAY', { days })
      .orderBy('h.calculatedAt', 'ASC')
      .getMany();

    return {
      userId,
      period: { days, from: histories[0]?.calculatedAt, to: new Date() },
      dataPoints: histories.map(h => ({
        date: h.calculatedAt,
        score: h.score,
        level: h.level,
      })),
      trend: this.calculateTrend(histories),
      insights: this.generateInsights(histories),
    };
  }

  /**
   * è®¡ç®—è¶‹åŠ¿æ–¹å‘
   */
  private calculateTrend(histories: UserHealthScore[]): 'improving' | 'stable' | 'declining' {
    if (histories.length < 2) return 'stable';

    const recent = histories.slice(-7);
    const earlier = histories.slice(-14, -7);

    const recentAvg = recent.reduce((sum, h) => sum + h.score, 0) / recent.length;
    const earlierAvg = earlier.reduce((sum, h) => sum + h.score, 0) / earlier.length;

    if (recentAvg > earlierAvg + 5) return 'improving';
    if (recentAvg < earlierAvg - 5) return 'declining';
    return 'stable';
  }

  /**
   * ç”Ÿæˆæ´å¯ŸæŠ¥å‘Š
   */
  private generateInsights(histories: UserHealthScore[]): string[] {
    const insights: string[] = [];

    if (histories.length === 0) return insights;

    const latest = histories[histories.length - 1];
    const trend = this.calculateTrend(histories);

    if (trend === 'declining') {
      insights.push('âš ï¸ å¥åº·åº¦å‘ˆä¸‹é™è¶‹åŠ¿ï¼Œéœ€è¦å…³æ³¨');
    } else if (trend === 'improving') {
      insights.push('âœ… å¥åº·åº¦æŒç»­æ”¹å–„ï¼Œä¿æŒè‰¯å¥½');
    }

    if (latest.activityScore < 20) {
      insights.push('ğŸ’¡ æ´»è·ƒåº¦è¾ƒä½ï¼Œå»ºè®®äº†è§£æœ€æ–°åŠŸèƒ½å’Œä¼˜æƒ æ´»åŠ¨');
    }

    if (latest.utilizationScore < 15) {
      insights.push('ğŸ’¡ èµ„æºåˆ©ç”¨ç‡åä½ï¼Œå¯èƒ½å­˜åœ¨é…ç½®ä¼˜åŒ–ç©ºé—´');
    }

    return insights;
  }

  /**
   * è·å–é«˜å±ç”¨æˆ·åˆ—è¡¨
   */
  async getHighRiskUsers(): Promise<UserHealthScore[]> {
    return this.healthScoreRepo.find({
      where: { churnRisk: true },
      order: { score: 'ASC', calculatedAt: 'DESC' },
      take: 100,
    });
  }
}

// ç±»å‹å®šä¹‰
enum HealthLevel {
  EXCELLENT = 'excellent',
  GOOD = 'good',
  FAIR = 'fair',
  POOR = 'poor',
  CRITICAL = 'critical',
}

interface InterventionStrategy {
  type: string;
  action: string;
  params: Record<string, any>;
}

interface HealthScoreTrend {
  userId: string;
  period: { days: number; from: Date; to: Date };
  dataPoints: Array<{ date: Date; score: number; level: string }>;
  trend: 'improving' | 'stable' | 'declining';
  insights: string[];
}
```

#### 1.4.4 è®¡ç®—å™¨å®ç°ç¤ºä¾‹

```typescript
// backend/user-service/src/health-score/calculators/activity-calculator.ts

import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from '../../entities/user.entity';
import { AuditLog } from '../../entities/audit-log.entity';

@Injectable()
export class ActivityCalculator {
  constructor(
    @InjectRepository(User)
    private userRepo: Repository<User>,
    @InjectRepository(AuditLog)
    private auditLogRepo: Repository<AuditLog>,
  ) {}

  /**
   * è®¡ç®—æ´»è·ƒåº¦å¾—åˆ† (æ»¡åˆ† 35 åˆ†)
   */
  async calculate(userId: string): Promise<number> {
    let score = 0;

    // 1. ç™»å½•é¢‘ç‡ (10 åˆ†)
    const loginScore = await this.calculateLoginScore(userId);
    score += loginScore;

    // 2. è®¾å¤‡ä½¿ç”¨æ—¶é•¿ (15 åˆ†)
    const usageScore = await this.calculateUsageScore(userId);
    score += usageScore;

    // 3. API è°ƒç”¨é¢‘ç‡ (10 åˆ†)
    const apiScore = await this.calculateApiScore(userId);
    score += apiScore;

    return Math.min(score, 35); // ä¸Šé™ 35 åˆ†
  }

  private async calculateLoginScore(userId: string): Promise<number> {
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    // ç»Ÿè®¡æœ€è¿‘30å¤©çš„ç™»å½•å¤©æ•°
    const loginDays = await this.auditLogRepo
      .createQueryBuilder('log')
      .select('DATE(log.createdAt)', 'date')
      .where('log.userId = :userId', { userId })
      .andWhere('log.action = :action', { action: 'user.login' })
      .andWhere('log.createdAt >= :since', { since: thirtyDaysAgo })
      .groupBy('DATE(log.createdAt)')
      .getRawMany();

    const loginDayCount = loginDays.length;

    // è¯„åˆ†è§„åˆ™
    if (loginDayCount >= 25) return 10; // å‡ ä¹æ¯å¤©ç™»å½•
    if (loginDayCount >= 20) return 8;  // 2/3 æ—¶é—´åœ¨çº¿
    if (loginDayCount >= 15) return 6;  // ä¸€åŠæ—¶é—´åœ¨çº¿
    if (loginDayCount >= 10) return 4;  // 1/3 æ—¶é—´åœ¨çº¿
    if (loginDayCount >= 5) return 2;   // å¶å°”ç™»å½•
    return 0; // æå°‘ç™»å½•
  }

  private async calculateUsageScore(userId: string): Promise<number> {
    // è°ƒç”¨ device-service API è·å–è®¾å¤‡ä½¿ç”¨æ•°æ®
    // è¿™é‡Œéœ€è¦é€šè¿‡ HttpClientService æˆ–ç›´æ¥æŸ¥è¯¢è®¾å¤‡æ•°æ®åº“

    // ç¤ºä¾‹ï¼šå‡è®¾å·²è·å–åˆ°å¹³å‡æ¯æ—¥ä½¿ç”¨æ—¶é•¿
    const avgDailyUsageHours = await this.getAvgDailyDeviceUsage(userId);

    if (avgDailyUsageHours >= 8) return 15;  // å…¨å¤©ä½¿ç”¨
    if (avgDailyUsageHours >= 6) return 12;  // å¤§éƒ¨åˆ†æ—¶é—´
    if (avgDailyUsageHours >= 4) return 9;   // åŠå¤©ä½¿ç”¨
    if (avgDailyUsageHours >= 2) return 6;   // å°‘é‡ä½¿ç”¨
    if (avgDailyUsageHours >= 1) return 3;   // æå°‘ä½¿ç”¨
    return 0; // å‡ ä¹ä¸ç”¨
  }

  private async calculateApiScore(userId: string): Promise<number> {
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    // ç»Ÿè®¡ API è°ƒç”¨æ¬¡æ•°ï¼ˆä» audit_logs æˆ–ä¸“é—¨çš„ API æ—¥å¿—è¡¨ï¼‰
    const apiCallCount = await this.auditLogRepo.count({
      where: {
        userId,
        action: Like('api.%'),
        createdAt: MoreThanOrEqual(thirtyDaysAgo),
      },
    });

    if (apiCallCount >= 1000) return 10; // é«˜é¢‘ä½¿ç”¨
    if (apiCallCount >= 500) return 8;
    if (apiCallCount >= 200) return 6;
    if (apiCallCount >= 50) return 4;
    if (apiCallCount >= 10) return 2;
    return 0; // æå°‘è°ƒç”¨
  }

  private async getAvgDailyDeviceUsage(userId: string): Promise<number> {
    // æ­¤å¤„éœ€è¦ä» device-service è·å–æ•°æ®
    // æˆ–è€…ç›´æ¥æŸ¥è¯¢ cloudphone_device æ•°æ®åº“çš„ device_usage_logs è¡¨

    // ä¼ªä»£ç ç¤ºä¾‹
    // const usageLogs = await deviceUsageRepo.find({ userId, since: 30daysAgo });
    // return calculateAverage(usageLogs);

    return 0; // å ä½ç¬¦
  }
}
```

### 1.5 å‰ç«¯å±•ç¤º

#### 1.5.1 ç®¡ç†åå°å¥åº·åº¦çœ‹æ¿

åœ¨ `frontend/admin` ä¸­æ·»åŠ å¥åº·åº¦ç›‘æ§é¡µé¢ï¼š

```tsx
// frontend/admin/src/pages/HealthScore/Dashboard.tsx

import React, { useState, useEffect } from 'react';
import { Card, Row, Col, Table, Tag, Progress, Statistic, Badge } from 'antd';
import { AlertOutlined, CheckCircleOutlined, WarningOutlined } from '@ant-design/icons';
import { Line } from '@ant-design/plots';

const HealthScoreDashboard: React.FC = () => {
  const [highRiskUsers, setHighRiskUsers] = useState([]);
  const [statistics, setStatistics] = useState({});

  // å¥åº·åº¦ç­‰çº§æ ‡ç­¾
  const renderHealthTag = (level: string) => {
    const config = {
      excellent: { color: 'green', text: 'ä¼˜ç§€' },
      good: { color: 'blue', text: 'å¥åº·' },
      fair: { color: 'orange', text: 'è§‚å¯Ÿ' },
      poor: { color: 'red', text: 'é¢„è­¦' },
      critical: { color: 'red', text: 'é«˜å±', icon: <AlertOutlined /> },
    };

    const { color, text, icon } = config[level] || {};
    return <Tag color={color} icon={icon}>{text}</Tag>;
  };

  // é«˜å±ç”¨æˆ·è¡¨æ ¼åˆ—
  const columns = [
    {
      title: 'ç”¨æˆ·ID',
      dataIndex: 'userId',
      key: 'userId',
    },
    {
      title: 'å¥åº·åº¦è¯„åˆ†',
      dataIndex: 'score',
      key: 'score',
      render: (score: number) => (
        <Progress
          percent={score}
          size="small"
          status={score < 60 ? 'exception' : 'normal'}
        />
      ),
      sorter: (a, b) => a.score - b.score,
    },
    {
      title: 'ç­‰çº§',
      dataIndex: 'level',
      key: 'level',
      render: renderHealthTag,
      filters: [
        { text: 'é«˜å±', value: 'critical' },
        { text: 'é¢„è­¦', value: 'poor' },
        { text: 'è§‚å¯Ÿ', value: 'fair' },
      ],
      onFilter: (value, record) => record.level === value,
    },
    {
      title: 'é£é™©å› ç´ ',
      dataIndex: 'riskFactors',
      key: 'riskFactors',
      render: (factors: string[]) => (
        <>
          {factors.map((factor, idx) => (
            <Tag key={idx} color="red">
              {factor.split('ï¼š')[0]}
            </Tag>
          ))}
        </>
      ),
    },
    {
      title: 'æœ€åè¯„ä¼°æ—¶é—´',
      dataIndex: 'calculatedAt',
      key: 'calculatedAt',
      render: (date: string) => new Date(date).toLocaleString('zh-CN'),
    },
    {
      title: 'å¹²é¢„çŠ¶æ€',
      dataIndex: 'interventionStatus',
      key: 'interventionStatus',
      render: (status: string) => {
        const statusMap = {
          pending: <Badge status="default" text="å¾…å¤„ç†" />,
          in_progress: <Badge status="processing" text="è¿›è¡Œä¸­" />,
          completed: <Badge status="success" text="å·²å®Œæˆ" />,
        };
        return statusMap[status] || '-';
      },
    },
    {
      title: 'æ“ä½œ',
      key: 'action',
      render: (_, record) => (
        <Space>
          <Button size="small" onClick={() => viewDetails(record.userId)}>
            è¯¦æƒ…
          </Button>
          <Button size="small" type="primary" onClick={() => intervene(record.userId)}>
            ç«‹å³å¹²é¢„
          </Button>
        </Space>
      ),
    },
  ];

  return (
    <div className="health-score-dashboard">
      <Row gutter={16} style={{ marginBottom: 24 }}>
        <Col span={6}>
          <Card>
            <Statistic
              title="é«˜å±ç”¨æˆ·"
              value={statistics.criticalCount}
              suffix="äºº"
              valueStyle={{ color: '#cf1322' }}
              prefix={<AlertOutlined />}
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic
              title="é¢„è­¦ç”¨æˆ·"
              value={statistics.poorCount}
              suffix="äºº"
              valueStyle={{ color: '#fa8c16' }}
              prefix={<WarningOutlined />}
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic
              title="å¥åº·ç”¨æˆ·"
              value={statistics.healthyCount}
              suffix="äºº"
              valueStyle={{ color: '#52c41a' }}
              prefix={<CheckCircleOutlined />}
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic
              title="å¹³å‡å¥åº·åº¦"
              value={statistics.avgScore}
              precision={1}
              valueStyle={{ color: '#1890ff' }}
            />
          </Card>
        </Col>
      </Row>

      <Card title="é«˜é£é™©ç”¨æˆ·åˆ—è¡¨" style={{ marginBottom: 24 }}>
        <Table
          columns={columns}
          dataSource={highRiskUsers}
          rowKey="userId"
          pagination={{ pageSize: 10 }}
        />
      </Card>

      <Card title="å¥åº·åº¦è¶‹åŠ¿">
        <Line
          data={statistics.trendData || []}
          xField="date"
          yField="avgScore"
          seriesField="level"
          smooth={true}
          animation={{
            appear: {
              animation: 'path-in',
              duration: 1000,
            },
          }}
        />
      </Card>
    </div>
  );
};

export default HealthScoreDashboard;
```

#### 1.5.2 ç”¨æˆ·ç«¯å¥åº·åº¦å±•ç¤º

åœ¨ç”¨æˆ·æ§åˆ¶å°å±•ç¤ºä¸ªäººå¥åº·åº¦æŠ¥å‘Šï¼š

```tsx
// frontend/user/src/pages/HealthReport.tsx

import React from 'react';
import { Card, Progress, List, Alert, Timeline } from 'antd';
import { CheckCircleOutlined, WarningOutlined } from '@ant-design/icons';

const HealthReport: React.FC = () => {
  const healthData = {
    score: 78,
    level: 'good',
    dimensions: {
      activity: 28,
      utilization: 20,
      stability: 16,
      growth: 10,
      engagement: 4,
    },
    insights: [
      'âœ… æ´»è·ƒåº¦è‰¯å¥½ï¼Œä¿æŒå½“å‰ä½¿ç”¨é¢‘ç‡',
      'ğŸ’¡ èµ„æºåˆ©ç”¨ç‡å¯ä»¥è¿›ä¸€æ­¥æå‡',
      'âš ï¸ å»ºè®®å‚ä¸ç¤¾åŒºäº’åŠ¨ï¼Œäº†è§£æ›´å¤šä½¿ç”¨æŠ€å·§',
    ],
  };

  return (
    <Card title="æˆ‘çš„å¥åº·åº¦æŠ¥å‘Š" extra={<Tag color="blue">å¥åº·ç”¨æˆ·</Tag>}>
      <Row gutter={24}>
        <Col span={8}>
          <Card>
            <Statistic
              title="å¥åº·åº¦è¯„åˆ†"
              value={healthData.score}
              suffix="/ 100"
              valueStyle={{ color: '#3f8600' }}
            />
            <Progress percent={healthData.score} strokeColor="#52c41a" />
          </Card>
        </Col>

        <Col span={16}>
          <Card title="ç»´åº¦è¯„åˆ†">
            <List
              dataSource={[
                { name: 'æ´»è·ƒåº¦', score: healthData.dimensions.activity, max: 35 },
                { name: 'èµ„æºåˆ©ç”¨ç‡', score: healthData.dimensions.utilization, max: 25 },
                { name: 'ç¨³å®šæ€§', score: healthData.dimensions.stability, max: 20 },
                { name: 'å¢é•¿æ€§', score: healthData.dimensions.growth, max: 15 },
                { name: 'äº’åŠ¨æ€§', score: healthData.dimensions.engagement, max: 5 },
              ]}
              renderItem={(item) => (
                <List.Item>
                  <div style={{ width: '100%' }}>
                    <div style={{ marginBottom: 8 }}>
                      {item.name}: {item.score} / {item.max} åˆ†
                    </div>
                    <Progress
                      percent={(item.score / item.max) * 100}
                      size="small"
                    />
                  </div>
                </List.Item>
              )}
            />
          </Card>
        </Col>
      </Row>

      <Card title="æ”¹è¿›å»ºè®®" style={{ marginTop: 24 }}>
        <List
          dataSource={healthData.insights}
          renderItem={(item) => <List.Item>{item}</List.Item>}
        />
      </Card>
    </Card>
  );
};
```

### 1.6 å®æ–½æ­¥éª¤

#### é˜¶æ®µ 1ï¼šåŸºç¡€è®¾æ–½ï¼ˆ1-2 å‘¨ï¼‰

1. **æ•°æ®åº“è®¾è®¡ä¸è¿ç§»**
   - åˆ›å»ºå¥åº·åº¦è¯„åˆ†è¡¨å’Œå†å²è®°å½•è¡¨
   - æ·»åŠ å¿…è¦çš„ç´¢å¼•

2. **æ ¸å¿ƒæœåŠ¡å¼€å‘**
   - å®ç° HealthScoreService å’Œå„ä¸ª Calculator
   - å•å…ƒæµ‹è¯•è¦†ç›–ç‡ > 80%

3. **äº‹ä»¶é›†æˆ**
   - é›†æˆ EventBusService å‘å¸ƒå¥åº·åº¦äº‹ä»¶
   - notification-service è®¢é˜…å¹²é¢„äº‹ä»¶

#### é˜¶æ®µ 2ï¼šè®¡ç®—é€»è¾‘ï¼ˆ2-3 å‘¨ï¼‰

4. **å®ç°å„ç»´åº¦è®¡ç®—å™¨**
   - ActivityCalculator
   - UtilizationCalculator
   - StabilityCalculator
   - GrowthCalculator
   - EngagementCalculator

5. **æ•°æ®é‡‡é›†ä¼˜åŒ–**
   - ç¡®ä¿å„æœåŠ¡æ­£ç¡®ä¸ŠæŠ¥æ‰€éœ€æŒ‡æ ‡
   - device-service æä¾›ä½¿ç”¨æ—¶é•¿ API
   - billing-service æä¾›æ¶ˆè´¹è¶‹åŠ¿ API

#### é˜¶æ®µ 3ï¼šå¹²é¢„ç³»ç»Ÿï¼ˆ2 å‘¨ï¼‰

6. **å¹²é¢„ç­–ç•¥å®ç°**
   - å®šä¹‰å¹²é¢„ç­–ç•¥è§„åˆ™
   - å®ç°è‡ªåŠ¨è§¦å‘é€»è¾‘
   - å¯¹æ¥é€šçŸ¥ç³»ç»Ÿ

7. **æ•ˆæœè¿½è¸ª**
   - è®°å½•å¹²é¢„å†å²
   - ç»Ÿè®¡å¹²é¢„æ•ˆæœ

#### é˜¶æ®µ 4ï¼šå‰ç«¯å±•ç¤ºï¼ˆ1-2 å‘¨ï¼‰

8. **ç®¡ç†åå°é¡µé¢**
   - å¥åº·åº¦çœ‹æ¿
   - é«˜å±ç”¨æˆ·åˆ—è¡¨
   - å¹²é¢„ç®¡ç†ç•Œé¢

9. **ç”¨æˆ·ç«¯é¡µé¢**
   - ä¸ªäººå¥åº·åº¦æŠ¥å‘Š
   - æ”¹è¿›å»ºè®®å±•ç¤º

#### é˜¶æ®µ 5ï¼šä¸Šçº¿ä¸ä¼˜åŒ–ï¼ˆæŒç»­ï¼‰

10. **ç°åº¦å‘å¸ƒ**
    - å…ˆå¯¹éƒ¨åˆ†ç”¨æˆ·è®¡ç®—å¥åº·åº¦
    - è§‚å¯Ÿç³»ç»Ÿæ€§èƒ½å½±å“

11. **æ¨¡å‹ä¼˜åŒ–**
    - æ ¹æ®å®é™…æµå¤±æ•°æ®è°ƒæ•´è¯„åˆ†æƒé‡
    - ä¼˜åŒ–å¹²é¢„ç­–ç•¥

---

## 2. æ™ºèƒ½è¿ç»´è‡ªåŠ¨åŒ–å¢å¼º

### 2.1 ç³»ç»Ÿç›®æ ‡

**æ ¸å¿ƒç›®æ ‡**ï¼šå‡å°‘äººå·¥è¿ç»´æˆæœ¬ï¼Œæé«˜æ•…éšœå“åº”é€Ÿåº¦ï¼Œå®ç°æ™ºèƒ½åŒ–çš„èµ„æºç®¡ç†å’Œé—®é¢˜é¢„é˜²ã€‚

**é¢„æœŸæ•ˆæœ**ï¼š
- äººå·¥è¿ç»´å·¥ä½œé‡å‡å°‘ 60%
- æ•…éšœå“åº”æ—¶é—´ç¼©çŸ­è‡³ < 5 åˆ†é’Ÿ
- è‡ªåŠ¨ä¿®å¤ç‡ > 70%

### 2.2 å¢å¼ºæ–¹æ¡ˆ

åŸºäºç°æœ‰çš„ `device-service/lifecycle` æ¨¡å—ï¼Œå¢å¼ºä»¥ä¸‹èƒ½åŠ›ï¼š

#### 2.2.1 æ™ºèƒ½å‘Šè­¦ç³»ç»Ÿ

**æ‰©å±• Prometheus å‘Šè­¦è§„åˆ™ï¼š**

```yaml
# infrastructure/monitoring/prometheus/intelligent-alert.rules.yml

groups:
  - name: intelligent_alerts
    interval: 30s
    rules:
      # æ™ºèƒ½è®¾å¤‡å¼‚å¸¸æ£€æµ‹
      - alert: DeviceAnomalyDetected
        expr: |
          (
            rate(device_errors_total[5m]) > 0.1
            or
            device_cpu_usage > 90
            or
            device_memory_usage > 90
          )
          and
          device_uptime_seconds > 300
        for: 3m
        labels:
          severity: warning
          component: device
          auto_heal: "true"
        annotations:
          summary: "è®¾å¤‡ {{ $labels.device_id }} å‡ºç°å¼‚å¸¸"
          description: "é”™è¯¯ç‡: {{ $value | humanize }}ï¼Œéœ€è¦è‡ªåŠ¨å¹²é¢„"
          auto_action: "restart_device"

      # èµ„æºåˆ©ç”¨ç‡å¼‚å¸¸ä½
      - alert: LowResourceUtilization
        expr: |
          (
            avg(device_cpu_usage) by (user_id) < 20
            and
            avg(device_memory_usage) by (user_id) < 30
          )
          and
          count(device_status == "running") by (user_id) > 1
        for: 24h
        labels:
          severity: info
          component: optimization
          auto_action: "true"
        annotations:
          summary: "ç”¨æˆ· {{ $labels.user_id }} èµ„æºåˆ©ç”¨ç‡è¿‡ä½"
          description: "å»ºè®®ä¼˜åŒ–è®¾å¤‡é…ç½®æˆ–ç¼©å‡å®ä¾‹æ•°é‡"
          auto_action: "send_optimization_suggestion"

      # é¢„æµ‹æ€§å‘Šè­¦ï¼šå³å°†è€—å°½èµ„æº
      - alert: ResourceExhaustionPredicted
        expr: |
          predict_linear(user_resource_usage[1h], 3600 * 24) > user_quota_limit
        for: 5m
        labels:
          severity: warning
          component: capacity
          auto_action: "true"
        annotations:
          summary: "é¢„æµ‹ç”¨æˆ· {{ $labels.user_id }} å°†åœ¨24å°æ—¶å†…è€—å°½é…é¢"
          description: "å½“å‰ä½¿ç”¨è¶‹åŠ¿: {{ $value | humanize }}"
          auto_action: "send_upgrade_notification"

      # æˆæœ¬å¼‚å¸¸å¢é•¿
      - alert: CostSpikeDetected
        expr: |
          rate(billing_cost_total[1h]) > (
            avg_over_time(billing_cost_total[24h:1h]) * 1.5
          )
        for: 15m
        labels:
          severity: critical
          component: billing
          auto_action: "true"
        annotations:
          summary: "ç”¨æˆ· {{ $labels.user_id }} æˆæœ¬å¼‚å¸¸å¢é•¿"
          description: "å½“å‰å¢é•¿ç‡: {{ $value | humanizePercentage }}"
          auto_action: "send_cost_alert_and_freeze_if_needed"
```

#### 2.2.2 è‡ªåŠ¨ä¿®å¤å¼•æ“

åœ¨ `device-service` ä¸­æ–°å¢è‡ªåŠ¨ä¿®å¤æ¨¡å—ï¼š

```typescript
// backend/device-service/src/auto-heal/auto-heal.service.ts

import { Injectable, Logger } from '@nestjs/common';
import { DevicesService } from '../devices/devices.service';
import { DockerService } from '../docker/docker.service';
import { EventBusService } from '@cloudphone/shared';

@Injectable()
export class AutoHealService {
  private readonly logger = new Logger(AutoHealService.name);

  constructor(
    private devicesService: DevicesService,
    private dockerService: DockerService,
    private eventBus: EventBusService,
  ) {}

  /**
   * å¤„ç† Prometheus å‘Šè­¦
   */
  async handleAlert(alert: PrometheusAlert): Promise<void> {
    this.logger.log(
      `æ”¶åˆ°å‘Šè­¦: ${alert.labels.alertname}, è®¾å¤‡: ${alert.labels.device_id}`
    );

    // æ£€æŸ¥æ˜¯å¦æ”¯æŒè‡ªåŠ¨ä¿®å¤
    if (alert.labels.auto_heal !== 'true') {
      this.logger.log('å‘Šè­¦ä¸æ”¯æŒè‡ªåŠ¨ä¿®å¤ï¼Œè·³è¿‡');
      return;
    }

    const autoAction = alert.annotations.auto_action;
    const deviceId = alert.labels.device_id;

    try {
      switch (autoAction) {
        case 'restart_device':
          await this.autoRestartDevice(deviceId, alert);
          break;

        case 'recreate_device':
          await this.autoRecreateDevice(deviceId, alert);
          break;

        case 'scale_down':
          await this.autoScaleDown(alert.labels.user_id, alert);
          break;

        case 'send_optimization_suggestion':
          await this.sendOptimizationSuggestion(alert.labels.user_id, alert);
          break;

        case 'send_upgrade_notification':
          await this.sendUpgradeNotification(alert.labels.user_id, alert);
          break;

        case 'send_cost_alert_and_freeze_if_needed':
          await this.handleCostSpike(alert.labels.user_id, alert);
          break;

        default:
          this.logger.warn(`æœªçŸ¥çš„è‡ªåŠ¨ä¿®å¤åŠ¨ä½œ: ${autoAction}`);
      }

      // è®°å½•ä¿®å¤å†å²
      await this.recordHealingAction(deviceId, autoAction, 'success');
    } catch (error) {
      this.logger.error(
        `è‡ªåŠ¨ä¿®å¤å¤±è´¥: ${autoAction}, è®¾å¤‡: ${deviceId}`,
        error.stack
      );
      await this.recordHealingAction(deviceId, autoAction, 'failed', error.message);

      // ä¿®å¤å¤±è´¥ï¼Œå‡çº§å‘Šè­¦
      await this.escalateAlert(alert, error);
    }
  }

  /**
   * è‡ªåŠ¨é‡å¯è®¾å¤‡
   */
  private async autoRestartDevice(
    deviceId: string,
    alert: PrometheusAlert
  ): Promise<void> {
    this.logger.log(`è‡ªåŠ¨é‡å¯è®¾å¤‡: ${deviceId}`);

    const device = await this.devicesService.findOne(deviceId);
    if (!device) {
      throw new Error(`è®¾å¤‡ä¸å­˜åœ¨: ${deviceId}`);
    }

    // æ£€æŸ¥é‡å¯é¢‘ç‡ï¼Œé¿å…è¿‡åº¦é‡å¯
    const recentRestarts = await this.getRecentRestartCount(deviceId, 3600); // 1å°æ—¶å†…
    if (recentRestarts >= 3) {
      this.logger.warn(`è®¾å¤‡ ${deviceId} é‡å¯è¿‡äºé¢‘ç¹ï¼Œæ”¹ä¸ºé‡å»º`);
      return this.autoRecreateDevice(deviceId, alert);
    }

    // æ‰§è¡Œé‡å¯
    await this.dockerService.restartContainer(device.containerId);

    // ç­‰å¾…è®¾å¤‡æ¢å¤
    await this.waitForDeviceHealthy(deviceId, 60000); // æœ€å¤šç­‰å¾…60ç§’

    // å‘å¸ƒäº‹ä»¶
    await this.eventBus.publishDeviceEvent('auto_healed', {
      deviceId,
      action: 'restart',
      reason: alert.annotations.summary,
      timestamp: new Date().toISOString(),
    });

    this.logger.log(`è®¾å¤‡ ${deviceId} è‡ªåŠ¨é‡å¯æˆåŠŸ`);
  }

  /**
   * è‡ªåŠ¨é‡å»ºè®¾å¤‡
   */
  private async autoRecreateDevice(
    deviceId: string,
    alert: PrometheusAlert
  ): Promise<void> {
    this.logger.log(`è‡ªåŠ¨é‡å»ºè®¾å¤‡: ${deviceId}`);

    const device = await this.devicesService.findOne(deviceId);
    if (!device) {
      throw new Error(`è®¾å¤‡ä¸å­˜åœ¨: ${deviceId}`);
    }

    // åˆ›å»ºå¤‡ä»½ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (device.backupEnabled) {
      await this.devicesService.createBackup(deviceId);
    }

    // åˆ é™¤æ—§è®¾å¤‡
    await this.devicesService.remove(deviceId);

    // åˆ›å»ºæ–°è®¾å¤‡ï¼ˆä½¿ç”¨ç›¸åŒé…ç½®ï¼‰
    const newDevice = await this.devicesService.create({
      userId: device.userId,
      name: device.name,
      spec: device.spec,
      androidVersion: device.androidVersion,
      restoreFromBackup: device.backupEnabled,
    });

    // å‘å¸ƒäº‹ä»¶
    await this.eventBus.publishDeviceEvent('auto_healed', {
      deviceId,
      newDeviceId: newDevice.id,
      action: 'recreate',
      reason: alert.annotations.summary,
      timestamp: new Date().toISOString(),
    });

    this.logger.log(`è®¾å¤‡ ${deviceId} è‡ªåŠ¨é‡å»ºæˆåŠŸï¼Œæ–°è®¾å¤‡: ${newDevice.id}`);
  }

  /**
   * è‡ªåŠ¨ç¼©å®¹
   */
  private async autoScaleDown(
    userId: string,
    alert: PrometheusAlert
  ): Promise<void> {
    this.logger.log(`ä¸ºç”¨æˆ· ${userId} æ‰§è¡Œè‡ªåŠ¨ç¼©å®¹å»ºè®®`);

    // è·å–ç”¨æˆ·çš„é—²ç½®è®¾å¤‡
    const idleDevices = await this.devicesService.findIdleDevices(userId, 24); // 24å°æ—¶æœªä½¿ç”¨

    if (idleDevices.length === 0) {
      this.logger.log('æ²¡æœ‰é—²ç½®è®¾å¤‡ï¼Œè·³è¿‡ç¼©å®¹');
      return;
    }

    // å‘é€é€šçŸ¥ï¼Œå»ºè®®ç”¨æˆ·åˆ é™¤é—²ç½®è®¾å¤‡
    await this.eventBus.publish('cloudphone.events', 'user.scale_down_suggested', {
      userId,
      idleDeviceCount: idleDevices.length,
      idleDeviceIds: idleDevices.map(d => d.id),
      potentialSavings: this.calculatePotentialSavings(idleDevices),
      timestamp: new Date().toISOString(),
    });

    this.logger.log(`å·²å‘ç”¨æˆ· ${userId} å‘é€ç¼©å®¹å»ºè®®ï¼Œé—²ç½®è®¾å¤‡æ•°: ${idleDevices.length}`);
  }

  /**
   * å‘é€ä¼˜åŒ–å»ºè®®
   */
  private async sendOptimizationSuggestion(
    userId: string,
    alert: PrometheusAlert
  ): Promise<void> {
    this.logger.log(`ä¸ºç”¨æˆ· ${userId} å‘é€èµ„æºä¼˜åŒ–å»ºè®®`);

    // åˆ†æç”¨æˆ·çš„èµ„æºä½¿ç”¨æ¨¡å¼
    const usagePattern = await this.analyzeUsagePattern(userId);

    // ç”Ÿæˆä¼˜åŒ–å»ºè®®
    const suggestions = this.generateOptimizationSuggestions(usagePattern);

    // å‘é€é€šçŸ¥
    await this.eventBus.publish('cloudphone.events', 'user.optimization_suggested', {
      userId,
      usagePattern,
      suggestions,
      potentialSavings: suggestions.reduce((sum, s) => sum + s.savingsPerMonth, 0),
      timestamp: new Date().toISOString(),
    });

    this.logger.log(`å·²å‘ç”¨æˆ· ${userId} å‘é€ä¼˜åŒ–å»ºè®®`);
  }

  /**
   * å‘é€å‡çº§é€šçŸ¥
   */
  private async sendUpgradeNotification(
    userId: string,
    alert: PrometheusAlert
  ): Promise<void> {
    this.logger.log(`ä¸ºç”¨æˆ· ${userId} å‘é€é…é¢å³å°†è€—å°½é€šçŸ¥`);

    // è·å–ç”¨æˆ·å½“å‰é…é¢å’Œä½¿ç”¨æƒ…å†µ
    const quotaInfo = await this.getUserQuotaInfo(userId);

    // è®¡ç®—é¢„è®¡è€—å°½æ—¶é—´
    const exhaustionEta = this.calculateExhaustionEta(quotaInfo);

    // å‘é€é€šçŸ¥
    await this.eventBus.publish('cloudphone.events', 'user.quota_exhaustion_warning', {
      userId,
      currentUsage: quotaInfo.currentUsage,
      quotaLimit: quotaInfo.limit,
      exhaustionEta,
      recommendedPlan: this.recommendUpgradePlan(quotaInfo),
      timestamp: new Date().toISOString(),
    });

    this.logger.log(`å·²å‘ç”¨æˆ· ${userId} å‘é€é…é¢é¢„è­¦é€šçŸ¥ï¼Œé¢„è®¡ ${exhaustionEta} è€—å°½`);
  }

  /**
   * å¤„ç†æˆæœ¬æ¿€å¢
   */
  private async handleCostSpike(
    userId: string,
    alert: PrometheusAlert
  ): Promise<void> {
    this.logger.warn(`ç”¨æˆ· ${userId} æˆæœ¬å¼‚å¸¸å¢é•¿`);

    // åˆ†ææˆæœ¬æ¿€å¢åŸå› 
    const costAnalysis = await this.analyzeCostSpike(userId);

    // å‘é€å‘Šè­¦é€šçŸ¥
    await this.eventBus.publish('cloudphone.events', 'billing.cost_spike_alert', {
      userId,
      costAnalysis,
      currentRate: costAnalysis.currentHourlyRate,
      normalRate: costAnalysis.normalHourlyRate,
      increasePercentage: costAnalysis.increasePercentage,
      timestamp: new Date().toISOString(),
    });

    // å¦‚æœè¶…è¿‡é˜ˆå€¼ï¼Œè€ƒè™‘è‡ªåŠ¨æš‚åœéƒ¨åˆ†èµ„æº
    if (costAnalysis.increasePercentage > 200) {
      this.logger.warn(`æˆæœ¬å¢é•¿è¶…è¿‡200%ï¼Œè€ƒè™‘è‡ªåŠ¨å†»ç»“æ–°èµ„æºåˆ›å»º`);

      // å‘å¸ƒäº‹ä»¶ï¼Œç”± user-service å¤„ç†é…é¢é™åˆ¶
      await this.eventBus.publishUserEvent('emergency_quota_freeze', {
        userId,
        reason: 'cost_spike',
        costAnalysis,
        timestamp: new Date().toISOString(),
      });
    }

    this.logger.log(`å·²å¤„ç†ç”¨æˆ· ${userId} çš„æˆæœ¬æ¿€å¢å‘Šè­¦`);
  }

  /**
   * å‡çº§å‘Šè­¦ï¼ˆå½“è‡ªåŠ¨ä¿®å¤å¤±è´¥æ—¶ï¼‰
   */
  private async escalateAlert(
    alert: PrometheusAlert,
    error: Error
  ): Promise<void> {
    this.logger.error(`å‘Šè­¦å‡çº§: ${alert.labels.alertname}`);

    // å‘é€ç»™è¿ç»´å›¢é˜Ÿ
    await this.eventBus.publish('cloudphone.events', 'ops.alert_escalated', {
      originalAlert: alert,
      autoHealError: error.message,
      severity: 'critical',
      requiresManualIntervention: true,
      timestamp: new Date().toISOString(),
    });
  }
}
```

#### 2.2.3 å®¹é‡è§„åˆ’ä¸é¢„æµ‹

```typescript
// backend/device-service/src/capacity/capacity-planning.service.ts

import { Injectable, Logger } from '@nestjs/common';
import { Cron } from '@nestjs/schedule';

@Injectable()
export class CapacityPlanningService {
  private readonly logger = new Logger(CapacityPlanningService.name);

  /**
   * æ¯æ—¥å®¹é‡è§„åˆ’æŠ¥å‘Š
   */
  @Cron('0 8 * * *') // æ¯å¤©æ—©ä¸Š8ç‚¹
  async generateDailyCapacityReport(): Promise<void> {
    this.logger.log('ç”Ÿæˆæ¯æ—¥å®¹é‡è§„åˆ’æŠ¥å‘Š');

    // 1. ç»Ÿè®¡å½“å‰èµ„æºä½¿ç”¨æƒ…å†µ
    const currentUsage = await this.getCurrentResourceUsage();

    // 2. é¢„æµ‹æœªæ¥7å¤©çš„èµ„æºéœ€æ±‚
    const forecast = await this.forecastResourceDemand(7);

    // 3. è¯†åˆ«å®¹é‡ç“¶é¢ˆ
    const bottlenecks = await this.identifyBottlenecks(currentUsage, forecast);

    // 4. ç”Ÿæˆæ‰©å®¹å»ºè®®
    const scalingRecommendations = await this.generateScalingRecommendations(
      currentUsage,
      forecast,
      bottlenecks
    );

    // 5. ç”ŸæˆæŠ¥å‘Š
    const report = {
      date: new Date(),
      currentUsage,
      forecast,
      bottlenecks,
      scalingRecommendations,
      estimatedCosts: this.estimateScalingCosts(scalingRecommendations),
    };

    // 6. å‘é€æŠ¥å‘Šç»™è¿è¥å›¢é˜Ÿ
    await this.sendCapacityReport(report);

    this.logger.log('å®¹é‡è§„åˆ’æŠ¥å‘Šå·²ç”Ÿæˆå¹¶å‘é€');
  }

  /**
   * é¢„æµ‹èµ„æºéœ€æ±‚ï¼ˆä½¿ç”¨çº¿æ€§å›å½’æˆ– ARIMA æ¨¡å‹ï¼‰
   */
  private async forecastResourceDemand(days: number): Promise<ResourceForecast> {
    // è·å–å†å²æ•°æ®
    const historicalData = await this.getHistoricalResourceUsage(30); // è¿‡å»30å¤©

    // ç®€å•çº¿æ€§å›å½’é¢„æµ‹
    const trend = this.calculateTrend(historicalData);

    // é¢„æµ‹æœªæ¥Nå¤©
    const forecast = [];
    for (let i = 1; i <= days; i++) {
      forecast.push({
        date: new Date(Date.now() + i * 24 * 3600 * 1000),
        predictedCpuCores: trend.cpu.slope * i + trend.cpu.intercept,
        predictedMemoryGB: trend.memory.slope * i + trend.memory.intercept,
        predictedDeviceCount: Math.round(trend.devices.slope * i + trend.devices.intercept),
        confidence: this.calculateConfidence(historicalData, i),
      });
    }

    return {
      forecastPeriodDays: days,
      predictions: forecast,
      accuracy: this.calculateAccuracy(historicalData),
    };
  }

  /**
   * è¯†åˆ«å®¹é‡ç“¶é¢ˆ
   */
  private async identifyBottlenecks(
    currentUsage: ResourceUsage,
    forecast: ResourceForecast
  ): Promise<Bottleneck[]> {
    const bottlenecks: Bottleneck[] = [];

    // æ£€æŸ¥å„é¡¹èµ„æºçš„å®¹é‡
    const capacityLimits = await this.getCapacityLimits();

    // CPU ç“¶é¢ˆ
    if (forecast.predictions[6].predictedCpuCores > capacityLimits.cpuCores * 0.8) {
      bottlenecks.push({
        resource: 'CPU',
        currentUsage: currentUsage.cpuCores,
        predictedUsage: forecast.predictions[6].predictedCpuCores,
        capacity: capacityLimits.cpuCores,
        utilizationPercentage: (forecast.predictions[6].predictedCpuCores / capacityLimits.cpuCores) * 100,
        severity: 'high',
        eta: this.calculateEta(currentUsage.cpuCores, forecast.predictions, capacityLimits.cpuCores * 0.8),
      });
    }

    // å†…å­˜ç“¶é¢ˆ
    if (forecast.predictions[6].predictedMemoryGB > capacityLimits.memoryGB * 0.8) {
      bottlenecks.push({
        resource: 'Memory',
        currentUsage: currentUsage.memoryGB,
        predictedUsage: forecast.predictions[6].predictedMemoryGB,
        capacity: capacityLimits.memoryGB,
        utilizationPercentage: (forecast.predictions[6].predictedMemoryGB / capacityLimits.memoryGB) * 100,
        severity: 'high',
        eta: this.calculateEta(currentUsage.memoryGB, forecast.predictions, capacityLimits.memoryGB * 0.8),
      });
    }

    // è®¾å¤‡æ•°é‡ç“¶é¢ˆ
    if (forecast.predictions[6].predictedDeviceCount > capacityLimits.maxDevices * 0.8) {
      bottlenecks.push({
        resource: 'Device Count',
        currentUsage: currentUsage.deviceCount,
        predictedUsage: forecast.predictions[6].predictedDeviceCount,
        capacity: capacityLimits.maxDevices,
        utilizationPercentage: (forecast.predictions[6].predictedDeviceCount / capacityLimits.maxDevices) * 100,
        severity: 'critical',
        eta: this.calculateEta(currentUsage.deviceCount, forecast.predictions, capacityLimits.maxDevices * 0.8),
      });
    }

    return bottlenecks;
  }

  /**
   * ç”Ÿæˆæ‰©å®¹å»ºè®®
   */
  private async generateScalingRecommendations(
    currentUsage: ResourceUsage,
    forecast: ResourceForecast,
    bottlenecks: Bottleneck[]
  ): Promise<ScalingRecommendation[]> {
    const recommendations: ScalingRecommendation[] = [];

    for (const bottleneck of bottlenecks) {
      const recommendation = {
        resource: bottleneck.resource,
        action: 'scale_up',
        currentCapacity: bottleneck.capacity,
        recommendedCapacity: this.calculateRecommendedCapacity(bottleneck),
        estimatedCost: this.estimateResourceCost(bottleneck.resource, this.calculateRecommendedCapacity(bottleneck)),
        urgency: bottleneck.severity,
        timeline: bottleneck.eta,
        reasoning: this.generateReasoningText(bottleneck),
      };

      recommendations.push(recommendation);
    }

    return recommendations;
  }

  /**
   * å‘é€å®¹é‡æŠ¥å‘Š
   */
  private async sendCapacityReport(report: CapacityReport): Promise<void> {
    // ç”Ÿæˆå¯è§†åŒ–æŠ¥å‘Š
    const reportHtml = this.generateReportHtml(report);

    // å‘é€é‚®ä»¶ç»™è¿è¥å›¢é˜Ÿ
    await this.eventBus.publish('cloudphone.events', 'ops.capacity_report_generated', {
      report,
      reportHtml,
      timestamp: new Date().toISOString(),
    });
  }
}
```

---

## 3. æˆæœ¬ä¸å®¹é‡ä¼˜åŒ–ç³»ç»Ÿ

### 3.1 ç³»ç»Ÿç›®æ ‡

**æ ¸å¿ƒç›®æ ‡**ï¼šå®æ—¶ç›‘æ§æˆæœ¬ï¼Œè¯†åˆ«æµªè´¹ï¼Œæä¾›ä¼˜åŒ–å»ºè®®ï¼Œå¸®åŠ©ç”¨æˆ·å’Œå¹³å°é™ä½è¿è¥æˆæœ¬ã€‚

**é¢„æœŸæ•ˆæœ**ï¼š
- å¹³å°æˆæœ¬é™ä½ 15-25%
- ç”¨æˆ·æˆæœ¬ä¼˜åŒ–å»ºè®®é‡‡çº³ç‡ > 40%
- é—²ç½®èµ„æºå›æ”¶ç‡ > 80%

### 3.2 æ¶æ„è®¾è®¡

åœ¨ `billing-service` ä¸­æ–°å¢æˆæœ¬ä¼˜åŒ–æ¨¡å—ï¼š

```
backend/billing-service/src/cost-optimization/
â”œâ”€â”€ cost-optimization.module.ts
â”œâ”€â”€ cost-optimization.service.ts
â”œâ”€â”€ cost-optimization.controller.ts
â”œâ”€â”€ cost-analysis.service.ts
â”œâ”€â”€ savings-calculator.service.ts
â”œâ”€â”€ recommendation-engine.service.ts
â””â”€â”€ entities/
    â”œâ”€â”€ cost-optimization-report.entity.ts
    â””â”€â”€ cost-saving-opportunity.entity.ts
```

### 3.3 æ ¸å¿ƒåŠŸèƒ½

#### 3.3.1 å®æ—¶æˆæœ¬ç›‘æ§

```typescript
// backend/billing-service/src/cost-optimization/cost-analysis.service.ts

@Injectable()
export class CostAnalysisService {
  /**
   * åˆ†æç”¨æˆ·æˆæœ¬ç»“æ„
   */
  async analyzeUserCosts(userId: string): Promise<CostAnalysisReport> {
    // 1. è·å–ç”¨æˆ·çš„æ‰€æœ‰èµ„æº
    const devices = await this.getUser Devices(userId);
    const proxies = await this.getUserProxies(userId);
    const storage = await this.getUserStorage(userId);

    // 2. è®¡ç®—å„é¡¹æˆæœ¬
    const deviceCosts = await this.calculateDeviceCosts(devices);
    const proxyCosts = await this.calculateProxyCosts(proxies);
    const storageCosts = await this.calculateStorageCosts(storage);

    // 3. æˆæœ¬åˆ†è§£
    const costBreakdown = {
      total: deviceCosts + proxyCosts + storageCosts,
      byCategory: {
        compute: deviceCosts,
        network: proxyCosts,
        storage: storageCosts,
      },
      byDevice: devices.map(d => ({
        deviceId: d.id,
        cost: this.calculateSingleDeviceCost(d),
        utilizationRate: d.utilizationRate,
        costEfficiency: d.utilizationRate > 0 ? this.calculateSingleDeviceCost(d) / d.utilizationRate : 0,
      })),
    };

    // 4. è¯†åˆ«å¼‚å¸¸
    const anomalies = this.detectCostAnomalies(costBreakdown);

    // 5. è¶‹åŠ¿åˆ†æ
    const trend = await this.analyzeCostTrend(userId, 30);

    return {
      userId,
      period: { start: moment().startOf('month'), end: moment().endOf('month') },
      costBreakdown,
      anomalies,
      trend,
      insights: this.generateCostInsights(costBreakdown, anomalies, trend),
    };
  }

  /**
   * æ£€æµ‹æˆæœ¬å¼‚å¸¸
   */
  private detectCostAnomalies(costBreakdown: CostBreakdown): CostAnomaly[] {
    const anomalies: CostAnomaly[] = [];

    // 1. é«˜æˆæœ¬ä½åˆ©ç”¨ç‡è®¾å¤‡
    const inefficientDevices = costBreakdown.byDevice.filter(
      d => d.cost > 100 && d.utilizationRate < 0.3 // æˆæœ¬>100ä¸”åˆ©ç”¨ç‡<30%
    );

    if (inefficientDevices.length > 0) {
      anomalies.push({
        type: 'low_utilization_high_cost',
        severity: 'medium',
        affectedResources: inefficientDevices.map(d => d.deviceId),
        estimatedWaste: inefficientDevices.reduce((sum, d) => sum + d.cost * (1 - d.utilizationRate), 0),
        recommendation: 'å»ºè®®é™ä½é…ç½®æˆ–åˆ é™¤é—²ç½®è®¾å¤‡',
      });
    }

    // 2. åƒµå°¸èµ„æºï¼ˆé•¿æ—¶é—´æœªä½¿ç”¨ï¼‰
    const zombieDevices = cost Breakdown.byDevice.filter(
      d => d.lastUsedAt && moment().diff(d.lastUsedAt, 'days') > 7
    );

    if (zombieDevices.length > 0) {
      anomalies.push({
        type: 'zombie_resources',
        severity: 'high',
        affectedResources: zombieDevices.map(d => d.deviceId),
        estimatedWaste: zombieDevices.reduce((sum, d) => sum + d.cost, 0),
        recommendation: 'å»ºè®®åˆ é™¤7å¤©ä»¥ä¸Šæœªä½¿ç”¨çš„è®¾å¤‡',
      });
    }

    // 3. é…ç½®è¿‡åº¦
    const overProvisionedDevices = costBreakdown.byDevice.filter(
      d => d.avgCpuUsage < 20 && d.avgMemoryUsage < 30
    );

    if (overProvisionedDevices.length > 0) {
      anomalies.push({
        type: 'over_provisioned',
        severity: 'low',
        affectedResources: overProvisionedDevices.map(d => d.deviceId),
        estimatedWaste: overProvisionedDevices.reduce(
          (sum, d) => sum + (d.cost * 0.5), // å‡è®¾å¯èŠ‚çœ50%
          0
        ),
        recommendation: 'å»ºè®®é™ä½è®¾å¤‡é…ç½®è§„æ ¼',
      });
    }

    return anomalies;
  }

  /**
   * ç”Ÿæˆæˆæœ¬æ´å¯Ÿ
   */
  private generateCostInsights(
    costBreakdown: CostBreakdown,
    anomalies: CostAnomaly[],
    trend: CostTrend
  ): string[] {
    const insights: string[] = [];

    // æ€»ä½“æˆæœ¬è¯„ä¼°
    if (trend.monthOverMonth > 20) {
      insights.push(`âš ï¸ æœ¬æœˆæˆæœ¬è¾ƒä¸Šæœˆå¢é•¿ ${trend.monthOverMonth.toFixed(1)}%ï¼Œè¯·å…³æ³¨`);
    } else if (trend.monthOverMonth < -10) {
      insights.push(`âœ… æœ¬æœˆæˆæœ¬è¾ƒä¸Šæœˆä¸‹é™ ${Math.abs(trend.monthOverMonth).toFixed(1)}%ï¼Œä¼˜åŒ–æœ‰æ•ˆ`);
    }

    // æˆæœ¬åˆ†å¸ƒ
    const computePercentage = (costBreakdown.byCategory.compute / costBreakdown.total) * 100;
    if (computePercentage > 70) {
      insights.push(`ğŸ’¡ è®¡ç®—æˆæœ¬å æ¯” ${computePercentage.toFixed(1)}%ï¼Œå»ºè®®ä¼˜åŒ–è®¾å¤‡é…ç½®`);
    }

    // æµªè´¹è¯†åˆ«
    const totalWaste = anomalies.reduce((sum, a) => sum + a.estimatedWaste, 0);
    if (totalWaste > 0) {
      insights.push(
        `ğŸ’° è¯†åˆ«åˆ° ${anomalies.length} é¡¹ä¼˜åŒ–æœºä¼šï¼Œé¢„è®¡å¯èŠ‚çœ Â¥${totalWaste.toFixed(2)}/æœˆ`
      );
    }

    // åˆ©ç”¨ç‡è¯„ä¼°
    const avgUtilization = costBreakdown.byDevice.reduce((sum, d) => sum + d.utilizationRate, 0) / costBreakdown.byDevice.length;
    if (avgUtilization < 0.5) {
      insights.push(`ğŸ“Š å¹³å‡èµ„æºåˆ©ç”¨ç‡ ${(avgUtilization * 100).toFixed(1)}%ï¼Œæœ‰è¾ƒå¤§ä¼˜åŒ–ç©ºé—´`);
    }

    return insights;
  }
}
```

#### 3.3.2 ä¼˜åŒ–å»ºè®®å¼•æ“

```typescript
// backend/billing-service/src/cost-optimization/recommendation-engine.service.ts

@Injectable()
export class RecommendationEngineService {
  /**
   * ç”Ÿæˆä¼˜åŒ–å»ºè®®
   */
  async generateRecommendations(userId: string): Promise<OptimizationRecommendation[]> {
    const recommendations: OptimizationRecommendation[] = [];

    // 1. è®¾å¤‡é…ç½®ä¼˜åŒ–
    const deviceRecommendations = await this.analyzeDeviceOptimization(userId);
    recommendations.push(...deviceRecommendations);

    // 2. å®šæ—¶å¯åœ
    const schedulingRecommendations = await this.analyzeSchedulingOpportunities(userId);
    recommendations.push(...schedulingRecommendations);

    // 3. é¢„ç•™å®ä¾‹
    const reservationRecommendations = await this.analyzeReservationOpportunities(userId);
    recommendations.push(...reservationRecommendations);

    // 4. Spot å®ä¾‹
    const spotRecommendations = await this.analyzeSpotOpportunities(userId);
    recommendations.push(...spotRecommendations);

    // æŒ‰èŠ‚çœé‡‘é¢æ’åº
    recommendations.sort((a, b) => b.estimatedSavings - a.estimatedSavings);

    return recommendations;
  }

  /**
   * åˆ†æè®¾å¤‡é…ç½®ä¼˜åŒ–æœºä¼š
   */
  private async analyzeDeviceOptimization(userId: string): Promise<OptimizationRecommendation[]> {
    const recommendations: OptimizationRecommendation[] = [];

    const devices = await this.getUserDevices(userId);

    for (const device of devices) {
      const usageStats = await this.getDeviceUsageStats(device.id, 7); // è¿‡å»7å¤©

      // èµ„æºåˆ©ç”¨ç‡ä½ï¼Œå»ºè®®é™é…
      if (usageStats.avgCpuUsage < 30 && usageStats.avgMemoryUsage < 40) {
        const currentSpec = device.spec;
        const recommendedSpec = this.downsizeSpec(currentSpec);

        const currentCost = this.calculateSpecCost(currentSpec);
        const recommendedCost = this.calculateSpecCost(recommendedSpec);
        const monthlySavings = (currentCost - recommendedCost) * 720; // 30å¤© * 24å°æ—¶

        recommendations.push({
          type: 'downsize_device',
          resourceId: device.id,
          resourceName: device.name,
          description: `è®¾å¤‡ ${device.name} å¹³å‡ CPU åˆ©ç”¨ç‡ ${usageStats.avgCpuUsage.toFixed(1)}%ï¼Œå†…å­˜åˆ©ç”¨ç‡ ${usageStats.avgMemoryUsage.toFixed(1)}%ï¼Œå»ºè®®é™ä½é…ç½®`,
          currentState: {
            spec: currentSpec,
            monthlyCost: currentCost * 720,
          },
          recommendedState: {
            spec: recommendedSpec,
            monthlyCost: recommendedCost * 720,
          },
          estimatedSavings: monthlySavings,
          savingsPercentage: ((monthlySavings / (currentCost * 720)) * 100).toFixed(1),
          effort: 'low', // å®æ–½éš¾åº¦
          riskLevel: 'low',
          priority: monthlySavings > 100 ? 'high' : 'medium',
          actionSteps: [
            '1. åˆ›å»ºè®¾å¤‡å¿«ç…§å¤‡ä»½',
            `2. å°†è®¾å¤‡è§„æ ¼ä» ${currentSpec} è°ƒæ•´ä¸º ${recommendedSpec}`,
            '3. é‡å¯è®¾å¤‡å¹¶éªŒè¯åº”ç”¨æ­£å¸¸è¿è¡Œ',
          ],
        });
      }
    }

    return recommendations;
  }

  /**
   * åˆ†æå®šæ—¶å¯åœæœºä¼š
   */
  private async analyzeSchedulingOpportunities(userId: string): Promise<OptimizationRecommendation[]> {
    const recommendations: OptimizationRecommendation[] = [];

    const devices = await this.getUserDevices(userId);

    for (const device of devices) {
      const usagePattern = await this.analyzeUsagePattern(device.id, 30); // è¿‡å»30å¤©

      // æ£€æµ‹æ˜æ˜¾çš„ç©ºé—²æ—¶æ®µ
      if (usagePattern.hasIdlePeriods) {
        const idleHours = usagePattern.idleHoursPerDay;
        const deviceCost = this.calculateDeviceCost(device);
        const hourlyCost = deviceCost / 720;
        const monthlySavings = idleHours * 30 * hourlyCost;

        recommendations.push({
          type: 'scheduled_start_stop',
          resourceId: device.id,
          resourceName: device.name,
          description: `è®¾å¤‡ ${device.name} æ¯å¤©æœ‰çº¦ ${idleHours.toFixed(1)} å°æ—¶å¤„äºç©ºé—²çŠ¶æ€ï¼Œå»ºè®®è®¾ç½®å®šæ—¶å¯åœ`,
          currentState: {
            runningMode: '24/7',
            monthlyCost: deviceCost,
          },
          recommendedState: {
            runningMode: `å®šæ—¶è¿è¡Œï¼ˆå·¥ä½œæ—¥ ${usagePattern.activeHoursStart}-${usagePattern.activeHoursEnd}ï¼‰`,
            monthlyCost: deviceCost - monthlySavings,
          },
          estimatedSavings: monthlySavings,
          savingsPercentage: ((monthlySavings / deviceCost) * 100).toFixed(1),
          effort: 'medium',
          riskLevel: 'medium',
          priority: monthlySavings > 50 ? 'high' : 'medium',
          actionSteps: [
            '1. ç¡®è®¤è®¾å¤‡çš„å®é™…ä½¿ç”¨æ—¶é—´æ®µ',
            '2. åœ¨æ§åˆ¶å°è®¾ç½®è®¾å¤‡å®šæ—¶å¯åœè§„åˆ™',
            `3. è®¾ç½®å®šæ—¶å¯åŠ¨æ—¶é—´: ${usagePattern.activeHoursStart}`,
            `4. è®¾ç½®å®šæ—¶åœæ­¢æ—¶é—´: ${usagePattern.activeHoursEnd}`,
            '5. ç›‘æ§1å‘¨ç¡®ä¿ä¸šåŠ¡ä¸å—å½±å“',
          ],
          usagePattern: {
            idleHoursPerDay: idleHours,
            activeHoursStart: usagePattern.activeHoursStart,
            activeHoursEnd: usagePattern.activeHoursEnd,
            weekdayPattern: usagePattern.weekdayPattern,
          },
        });
      }
    }

    return recommendations;
  }

  /**
   * åˆ†æé¢„ç•™å®ä¾‹æœºä¼š
   */
  private async analyzeReservationOpportunities(userId: string): Promise<OptimizationRecommendation[]> {
    const recommendations: OptimizationRecommendation[] = [];

    // è·å–ç”¨æˆ·çš„é•¿æœŸç¨³å®šè¿è¡Œè®¾å¤‡
    const stableDevices = await this.getStableDevices(userId, 90); // 90å¤©å†…ç¨³å®šè¿è¡Œ

    if (stableDevices.length > 0) {
      const totalOnDemandCost = stableDevices.reduce(
        (sum, d) => sum + this.calculateDeviceCost(d),
        0
      );

      // é¢„ç•™å®ä¾‹é€šå¸¸æœ‰30-70%çš„æŠ˜æ‰£
      const reservedCost = totalOnDemandCost * 0.5; // å‡è®¾50%æŠ˜æ‰£
      const annualSavings = (totalOnDemandCost - reservedCost) * 12;

      recommendations.push({
        type: 'reserved_instances',
        resourceIds: stableDevices.map(d => d.id),
        description: `æ‚¨æœ‰ ${stableDevices.length} å°è®¾å¤‡å·²æŒç»­è¿è¡Œè¶…è¿‡ 90 å¤©ï¼Œå»ºè®®è´­ä¹°é¢„ç•™å®ä¾‹ä»¥è·å¾—æŠ˜æ‰£`,
        currentState: {
          pricingModel: 'æŒ‰éœ€è®¡è´¹ï¼ˆPay-as-you-goï¼‰',
          monthlyCost: totalOnDemandCost,
          annualCost: totalOnDemandCost * 12,
        },
        recommendedState: {
          pricingModel: 'é¢„ç•™å®ä¾‹ï¼ˆ1å¹´æœŸï¼Œ50%æŠ˜æ‰£ï¼‰',
          monthlyCost: reservedCost,
          annualCost: reservedCost * 12,
        },
        estimatedSavings: annualSavings / 12, // æœˆå‡èŠ‚çœ
        savingsPercentage: '50',
        effort: 'low',
        riskLevel: 'low',
        priority: annualSavings > 1000 ? 'high' : 'medium',
        actionSteps: [
          '1. ç¡®è®¤è¿™äº›è®¾å¤‡å°†é•¿æœŸä½¿ç”¨ï¼ˆè‡³å°‘1å¹´ï¼‰',
          '2. é€‰æ‹©åˆé€‚çš„é¢„ç•™å®ä¾‹å¥—é¤ï¼ˆ1å¹´æˆ–3å¹´ï¼‰',
          '3. å®Œæˆé¢„ç•™å®ä¾‹è´­ä¹°',
          '4. è®¾å¤‡å°†è‡ªåŠ¨åº”ç”¨é¢„ç•™å®ä¾‹æŠ˜æ‰£',
        ],
        additionalInfo: {
          commitmentPeriod: '1å¹´',
          paymentOption: 'å…¨é¢„ä»˜/éƒ¨åˆ†é¢„ä»˜/æ— é¢„ä»˜',
          flexibility: 'å¯åœ¨åŒè§„æ ¼è®¾å¤‡é—´çµæ´»åˆ†é…',
        },
      });
    }

    return recommendations;
  }
}
```

#### 3.3.3 æˆæœ¬å¯è§†åŒ–ä»ªè¡¨æ¿

å‰ç«¯å±•ç¤ºï¼š

```tsx
// frontend/admin/src/pages/CostOptimization/Dashboard.tsx

const CostOptimizationDashboard: React.FC = () => {
  return (
    <div>
      {/* æˆæœ¬æ¦‚è§ˆ */}
      <Row gutter={16}>
        <Col span={6}>
          <Card>
            <Statistic
              title="æœ¬æœˆæ€»æˆæœ¬"
              value={statistics.totalCost}
              prefix="Â¥"
              precision={2}
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic
              title="å¯èŠ‚çœé‡‘é¢"
              value={statistics.potentialSavings}
              prefix="Â¥"
              precision={2}
              valueStyle={{ color: '#3f8600' }}
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic
              title="å¹³å‡åˆ©ç”¨ç‡"
              value={statistics.avgUtilization}
              suffix="%"
              precision={1}
            />
          </Card>
        </Col>
        <Col span={6}>
          <Card>
            <Statistic
              title="ä¼˜åŒ–å»ºè®®"
              value={recommendations.length}
              suffix="æ¡"
            />
          </Card>
        </Col>
      </Row>

      {/* æˆæœ¬è¶‹åŠ¿ */}
      <Card title="æˆæœ¬è¶‹åŠ¿" style={{ marginTop: 24 }}>
        <Line
          data={costTrendData}
          xField="date"
          yField="cost"
          seriesField="category"
        />
      </Card>

      {/* æˆæœ¬åˆ†è§£ */}
      <Row gutter={16} style={{ marginTop: 24 }}>
        <Col span={12}>
          <Card title="æˆæœ¬åˆ†ç±»">
            <Pie
              data={costBreakdownData}
              angleField="value"
              colorField="type"
              radius={0.8}
              label={{
                type: 'outer',
                content: '{name} {percentage}',
              }}
            />
          </Card>
        </Col>
        <Col span={12}>
          <Card title="èµ„æºåˆ©ç”¨ç‡åˆ†å¸ƒ">
            <Column
              data={utilizationData}
              xField="device"
              yField="utilization"
              meta={{
                utilization: {
                  alias: 'åˆ©ç”¨ç‡',
                  max: 100,
                },
              }}
            />
          </Card>
        </Col>
      </Row>

      {/* ä¼˜åŒ–å»ºè®®åˆ—è¡¨ */}
      <Card title="ä¼˜åŒ–å»ºè®®" style={{ marginTop: 24 }}>
        <List
          dataSource={recommendations}
          renderItem={(item) => (
            <List.Item
              actions={[
                <Button type="primary" onClick={() => implementRecommendation(item)}>
                  é‡‡çº³å»ºè®®
                </Button>,
                <Button onClick={() => viewDetails(item)}>æŸ¥çœ‹è¯¦æƒ…</Button>,
              ]}
            >
              <List.Item.Meta
                avatar={<Avatar icon={getRecommendationIcon(item.type)} />}
                title={
                  <Space>
                    <span>{item.description}</span>
                    <Tag color="green">å¯èŠ‚çœ Â¥{item.estimatedSavings.toFixed(2)}/æœˆ</Tag>
                    <Tag color={getPriorityColor(item.priority)}>{item.priority}</Tag>
                  </Space>
                }
                description={
                  <Space direction="vertical">
                    <div>
                      å½“å‰é…ç½®: {JSON.stringify(item.currentState)}
                    </div>
                    <div>
                      å»ºè®®é…ç½®: {JSON.stringify(item.recommendedState)}
                    </div>
                    <div>
                      èŠ‚çœæ¯”ä¾‹: {item.savingsPercentage}%
                    </div>
                  </Space>
                }
              />
            </List.Item>
          )}
        />
      </Card>
    </div>
  );
};
```

---

## 4. å·¥å•ä¸æ”¯æŒç³»ç»Ÿä¼˜åŒ–

### 4.1 ç³»ç»Ÿç›®æ ‡

**æ ¸å¿ƒç›®æ ‡**ï¼šæå‡å·¥å•å¤„ç†æ•ˆç‡ï¼Œå‡å°‘å“åº”æ—¶é—´ï¼Œé€šè¿‡æ™ºèƒ½åŒ–é™ä½äººå·¥ä»‹å…¥éœ€æ±‚ã€‚

**é¢„æœŸæ•ˆæœ**ï¼š
- å·¥å•å“åº”æ—¶é—´ç¼©çŸ­ 50%
- è‡ªåŠ¨å›å¤ç‡ > 40%
- ç”¨æˆ·æ»¡æ„åº¦æå‡è‡³ > 4.5/5.0

### 4.2 å¢å¼ºæ–¹æ¡ˆ

åŸºäº `user-service` ç°æœ‰çš„ tickets æ¨¡å—ï¼Œå¢å¼ºä»¥ä¸‹èƒ½åŠ›ï¼š

#### 4.2.1 æ™ºèƒ½åˆ†ç±»ä¸è·¯ç”±

```typescript
// backend/user-service/src/tickets/intelligent-routing.service.ts

import { Injectable } from '@nestjs/common';
import { CreateTicketDto } from './dto/create-ticket.dto';

@Injectable()
export class IntelligentRoutingService {
  /**
   * æ™ºèƒ½åˆ†ç±»å·¥å•
   */
  async classifyTicket(ticket: CreateTicketDto): Promise<TicketClassification> {
    // ä½¿ç”¨å…³é”®è¯åŒ¹é… + NLPï¼ˆå¦‚æœé›†æˆäº†AIæœåŠ¡ï¼‰
    const classification = {
      category: this.detectCategory(ticket.title, ticket.description),
      priority: this.detectPriority(ticket.title, ticket.description),
      suggestedTags: this.extractTags(ticket.description),
      relatedFaq: await this.findRelatedFaq(ticket.description),
      autoResolvable: false,
      autoResponse: null,
    };

    // æ£€æŸ¥æ˜¯å¦å¯ä»¥è‡ªåŠ¨å›å¤
    if (classification.relatedFaq.length > 0 && classification.relatedFaq[0].relevanceScore > 0.8) {
      classification.autoResolvable = true;
      classification.autoResponse = this.generateAutoResponse(classification.relatedFaq[0]);
    }

    return classification;
  }

  /**
   * æ£€æµ‹å·¥å•ç±»åˆ«
   */
  private detectCategory(title: string, description: string): TicketCategory {
    const text = `${title} ${description}`.toLowerCase();

    // å…³é”®è¯åŒ¹é…è§„åˆ™
    const rules = [
      {
        category: TicketCategory.DEVICE_ISSUE,
        keywords: ['è®¾å¤‡', 'å¯åŠ¨å¤±è´¥', 'é»‘å±', 'å¡é¡¿', 'adb', 'è¿æ¥ä¸ä¸Š'],
      },
      {
        category: TicketCategory.BILLING_ISSUE,
        keywords: ['è´¦å•', 'æ‰£è´¹', 'å……å€¼', 'å‘ç¥¨', 'é€€æ¬¾', 'ä»·æ ¼'],
      },
      {
        category: TicketCategory.ACCOUNT_ISSUE,
        keywords: ['è´¦å·', 'ç™»å½•', 'å¯†ç ', 'å¿˜è®°', 'æ— æ³•è®¿é—®', 'æƒé™'],
      },
      {
        category: TicketCategory.FEATURE_REQUEST,
        keywords: ['å»ºè®®', 'åŠŸèƒ½', 'å¸Œæœ›', 'èƒ½å¦', 'æ”¯æŒ', 'æ–°å¢'],
      },
      {
        category: TicketCategory.TECHNICAL_SUPPORT,
        keywords: ['å¦‚ä½•', 'æ€ä¹ˆ', 'æ•™ç¨‹', 'æ–‡æ¡£', 'ä½¿ç”¨', 'api'],
      },
    ];

    for (const rule of rules) {
      if (rule.keywords.some(keyword => text.includes(keyword))) {
        return rule.category;
      }
    }

    return TicketCategory.GENERAL;
  }

  /**
   * æ£€æµ‹ä¼˜å…ˆçº§
   */
  private detectPriority(title: string, description: string): TicketPriority {
    const text = `${title} ${description}`.toLowerCase();

    // ç´§æ€¥å…³é”®è¯
    const urgentKeywords = ['ç´§æ€¥', 'ä¸¥é‡', 'æ— æ³•ä½¿ç”¨', 'ç”Ÿäº§ç¯å¢ƒ', 'å´©æºƒ', 'å®•æœº'];
    if (urgentKeywords.some(k => text.includes(k))) {
      return TicketPriority.URGENT;
    }

    // é«˜ä¼˜å…ˆçº§å…³é”®è¯
    const highKeywords = ['å½±å“', 'é‡è¦', 'å°½å¿«', 'é¢‘ç¹', 'å¤šæ¬¡'];
    if (highKeywords.some(k => text.includes(k))) {
      return TicketPriority.HIGH;
    }

    return TicketPriority.NORMAL;
  }

  /**
   * æŸ¥æ‰¾ç›¸å…³ FAQ
   */
  private async findRelatedFaq(description: string): Promise<RelatedFaq[]> {
    // è¿™é‡Œå¯ä»¥é›†æˆå‘é‡ç›¸ä¼¼åº¦æœç´¢æˆ–å…¨æ–‡æœç´¢
    // ç¤ºä¾‹ï¼šä½¿ç”¨ PostgreSQL çš„å…¨æ–‡æœç´¢
    const faqs = await this.faqRepo
      .createQueryBuilder('faq')
      .select()
      .addSelect(
        `ts_rank(to_tsvector('chinese', question || ' ' || answer), plainto_tsquery('chinese', :query))`,
        'relevance'
      )
      .where(
        `to_tsvector('chinese', question || ' ' || answer) @@ plainto_tsquery('chinese', :query)`,
        { query: description }
      )
      .orderBy('relevance', 'DESC')
      .limit(3)
      .getRawMany();

    return faqs.map(faq => ({
      id: faq.id,
      question: faq.question,
      answer: faq.answer,
      relevanceScore: faq.relevance,
    }));
  }

  /**
   * ç”Ÿæˆè‡ªåŠ¨å›å¤
   */
  private generateAutoResponse(faq: RelatedFaq): string {
    return `
æ„Ÿè°¢æ‚¨çš„å’¨è¯¢ï¼æˆ‘ä»¬æ£€æµ‹åˆ°æ‚¨çš„é—®é¢˜å¯èƒ½ä¸ä»¥ä¸‹å†…å®¹ç›¸å…³ï¼š

**${faq.question}**

${faq.answer}

å¦‚æœä»¥ä¸Šå†…å®¹æœªèƒ½è§£å†³æ‚¨çš„é—®é¢˜ï¼Œæˆ‘ä»¬çš„å·¥ç¨‹å¸ˆä¼šå°½å¿«ä¸ºæ‚¨å¤„ç†ã€‚

æ­¤å·¥å•å°†è‡ªåŠ¨æ ‡è®°ä¸º"å¾…ç¡®è®¤"ï¼Œå¦‚å·²è§£å†³è¯·å›å¤"å·²è§£å†³"å…³é—­å·¥å•ã€‚
    `.trim();
  }

  /**
   * æ™ºèƒ½è·¯ç”±åˆ°åˆé€‚çš„å¤„ç†äºº
   */
  async routeTicket(ticket: Ticket, classification: TicketClassification): Promise<string> {
    // æ ¹æ®ç±»åˆ«åˆ†é…ç»™ä¸åŒå›¢é˜Ÿ/äººå‘˜
    const routingRules = {
      [TicketCategory.DEVICE_ISSUE]: 'device-support-team',
      [TicketCategory.BILLING_ISSUE]: 'billing-support-team',
      [TicketCategory.ACCOUNT_ISSUE]: 'account-support-team',
      [TicketCategory.FEATURE_REQUEST]: 'product-team',
      [TicketCategory.TECHNICAL_SUPPORT]: 'technical-support-team',
    };

    const team = routingRules[classification.category] || 'general-support-team';

    // è·å–è¯¥å›¢é˜Ÿå½“å‰å·¥ä½œè´Ÿè½½æœ€ä½çš„æˆå‘˜
    const assignee = await this.findAvailableAgent(team);

    return assignee;
  }

  /**
   * æŸ¥æ‰¾å¯ç”¨çš„å®¢æœäººå‘˜
   */
  private async findAvailableAgent(team: string): Promise<string> {
    // æŸ¥è¯¢è¯¥å›¢é˜Ÿæˆå‘˜çš„å½“å‰å·¥å•æ•°
    const agents = await this.userRepo.find({
      where: { team, role: 'support_agent' },
    });

    const agentLoads = await Promise.all(
      agents.map(async (agent) => ({
        agentId: agent.id,
        openTickets: await this.ticketRepo.count({
          where: { assigneeId: agent.id, status: In([TicketStatus.OPEN, TicketStatus.IN_PROGRESS]) },
        }),
      }))
    );

    // è¿”å›å·¥å•æ•°æœ€å°‘çš„äººå‘˜
    agentLoads.sort((a, b) => a.openTickets - b.openTickets);
    return agentLoads[0].agentId;
  }
}
```

#### 4.2.2 çŸ¥è¯†åº“ä¸ FAQ ç®¡ç†

```typescript
// backend/user-service/src/knowledge-base/knowledge-base.service.ts

@Injectable()
export class KnowledgeBaseService {
  /**
   * åˆ›å»º FAQ
   */
  async createFaq(dto: CreateFaqDto): Promise<Faq> {
    return this.faqRepo.save({
      question: dto.question,
      answer: dto.answer,
      category: dto.category,
      tags: dto.tags,
      viewCount: 0,
      helpfulCount: 0,
    });
  }

  /**
   * æœç´¢ FAQ
   */
  async searchFaq(query: string): Promise<Faq[]> {
    // ä½¿ç”¨ PostgreSQL å…¨æ–‡æœç´¢
    return this.faqRepo
      .createQueryBuilder('faq')
      .where(
        `to_tsvector('chinese', question || ' ' || answer) @@ plainto_tsquery('chinese', :query)`,
        { query }
      )
      .orderBy(
        `ts_rank(to_tsvector('chinese', question || ' ' || answer), plainto_tsquery('chinese', :query))`,
        'DESC'
      )
      .limit(10)
      .getMany();
  }

  /**
   * ä»å·²è§£å†³å·¥å•ä¸­å­¦ä¹ ï¼Œç”Ÿæˆ FAQ
   */
  @Cron('0 3 * * *') // æ¯å¤©å‡Œæ™¨3ç‚¹
  async extractFaqFromTickets(): Promise<void> {
    // æŸ¥æ‰¾æœ€è¿‘è§£å†³çš„å·¥å•
    const resolvedTickets = await this.ticketRepo.find({
      where: {
        status: TicketStatus.RESOLVED,
        resolvedAt: MoreThan(moment().subtract(7, 'days').toDate()),
      },
      order: { resolvedAt: 'DESC' },
      take: 100,
    });

    // åˆ†æé«˜é¢‘é—®é¢˜
    const frequentIssues = this.identifyFrequentIssues(resolvedTickets);

    // ä¸ºé«˜é¢‘é—®é¢˜ç”Ÿæˆ FAQ
    for (const issue of frequentIssues) {
      if (issue.count >= 5) { // å‡ºç°5æ¬¡ä»¥ä¸Šçš„é—®é¢˜
        const existingFaq = await this.faqRepo.findOne({
          where: { question: issue.question },
        });

        if (!existingFaq) {
          await this.createFaq({
            question: issue.question,
            answer: issue.commonSolution,
            category: issue.category,
            tags: issue.tags,
          });

          this.logger.log(`è‡ªåŠ¨åˆ›å»º FAQ: ${issue.question}`);
        }
      }
    }
  }

  /**
   * è¯†åˆ«é«˜é¢‘é—®é¢˜
   */
  private identifyFrequentIssues(tickets: Ticket[]): FrequentIssue[] {
    // ç®€å•çš„å…³é”®è¯èšç±»
    const issueGroups = new Map<string, Ticket[]>();

    for (const ticket of tickets) {
      const keywords = this.extractKeywords(ticket.title);
      const key = keywords.join('_');

      if (!issueGroups.has(key)) {
        issueGroups.set(key, []);
      }
      issueGroups.get(key).push(ticket);
    }

    // è½¬æ¢ä¸ºé¢‘ç‡ç»Ÿè®¡
    const frequentIssues: FrequentIssue[] = [];

    for (const [key, group] of issueGroups.entries()) {
      if (group.length >= 5) {
        frequentIssues.push({
          question: this.generateQuestion(group[0]),
          commonSolution: this.findCommonSolution(group),
          category: group[0].category,
          tags: this.extractKeywords(group[0].title),
          count: group.length,
        });
      }
    }

    return frequentIssues;
  }
}
```

#### 4.2.3 å·¥å•ç»©æ•ˆåˆ†æ

```typescript
// backend/user-service/src/tickets/ticket-analytics.service.ts

@Injectable()
export class TicketAnalyticsService {
  /**
   * ç”Ÿæˆå·¥å•ç»©æ•ˆæŠ¥å‘Š
   */
  async generatePerformanceReport(period: 'day' | 'week' | 'month'): Promise<TicketPerformanceReport> {
    const startDate = this.getStartDate(period);

    // 1. æ€»ä½“æŒ‡æ ‡
    const totalTickets = await this.ticketRepo.count({
      where: { createdAt: MoreThanOrEqual(startDate) },
    });

    const resolvedTickets = await this.ticketRepo.count({
      where: {
        createdAt: MoreThanOrEqual(startDate),
        status: TicketStatus.RESOLVED,
      },
    });

    // 2. å¹³å‡å“åº”æ—¶é—´
    const avgResponseTime = await this.calculateAvgResponseTime(startDate);

    // 3. å¹³å‡è§£å†³æ—¶é—´
    const avgResolutionTime = await this.calculateAvgResolutionTime(startDate);

    // 4. è‡ªåŠ¨å›å¤ç‡
    const autoReplyRate = await this.calculateAutoReplyRate(startDate);

    // 5. ç”¨æˆ·æ»¡æ„åº¦
    const avgSatisfaction = await this.calculateAvgSatisfaction(startDate);

    // 6. æŒ‰ç±»åˆ«ç»Ÿè®¡
    const byCategory = await this.getTicketsByCategory(startDate);

    // 7. å®¢æœç»©æ•ˆ
    const agentPerformance = await this.getAgentPerformance(startDate);

    return {
      period,
      startDate,
      endDate: new Date(),
      summary: {
        totalTickets,
        resolvedTickets,
        resolutionRate: (resolvedTickets / totalTickets) * 100,
        avgResponseTime, // åˆ†é’Ÿ
        avgResolutionTime, // å°æ—¶
        autoReplyRate, // ç™¾åˆ†æ¯”
        avgSatisfaction, // 1-5åˆ†
      },
      byCategory,
      agentPerformance,
      trends: await this.calculateTrends(period),
    };
  }

  /**
   * è®¡ç®—å¹³å‡å“åº”æ—¶é—´
   */
  private async calculateAvgResponseTime(since: Date): Promise<number> {
    const result = await this.ticketRepo
      .createQueryBuilder('ticket')
      .select('AVG(EXTRACT(EPOCH FROM (first_response_at - created_at)) / 60)', 'avgMinutes')
      .where('ticket.createdAt >= :since', { since })
      .andWhere('ticket.firstResponseAt IS NOT NULL')
      .getRawOne();

    return Math.round(result?.avgMinutes || 0);
  }

  /**
   * è®¡ç®—å¹³å‡è§£å†³æ—¶é—´
   */
  private async calculateAvgResolutionTime(since: Date): Promise<number> {
    const result = await this.ticketRepo
      .createQueryBuilder('ticket')
      .select('AVG(EXTRACT(EPOCH FROM (resolved_at - created_at)) / 3600)', 'avgHours')
      .where('ticket.createdAt >= :since', { since })
      .andWhere('ticket.status = :status', { status: TicketStatus.RESOLVED })
      .getRawOne();

    return Math.round(result?.avgHours || 0);
  }

  /**
   * å®¢æœç»©æ•ˆç»Ÿè®¡
   */
  private async getAgentPerformance(since: Date): Promise<AgentPerformance[]> {
    const agents = await this.ticketRepo
      .createQueryBuilder('ticket')
      .select('ticket.assigneeId', 'agentId')
      .addSelect('COUNT(*)', 'totalHandled')
      .addSelect(
        'COUNT(CASE WHEN ticket.status = :resolved THEN 1 END)',
        'resolvedCount'
      )
      .addSelect(
        'AVG(EXTRACT(EPOCH FROM (first_response_at - created_at)) / 60)',
        'avgResponseMinutes'
      )
      .addSelect(
        'AVG(EXTRACT(EPOCH FROM (resolved_at - created_at)) / 3600)',
        'avgResolutionHours'
      )
      .addSelect('AVG(ticket.satisfactionScore)', 'avgSatisfaction')
      .where('ticket.createdAt >= :since', { since })
      .andWhere('ticket.assigneeId IS NOT NULL')
      .groupBy('ticket.assigneeId')
      .setParameter('resolved', TicketStatus.RESOLVED)
      .getRawMany();

    return agents.map(a => ({
      agentId: a.agentId,
      agentName: a.agentName,
      totalHandled: parseInt(a.totalHandled),
      resolvedCount: parseInt(a.resolvedCount),
      resolutionRate: (parseInt(a.resolvedCount) / parseInt(a.totalHandled)) * 100,
      avgResponseTime: Math.round(a.avgResponseMinutes),
      avgResolutionTime: Math.round(a.avgResolutionHours),
      avgSatisfaction: parseFloat(a.avgSatisfaction).toFixed(2),
    }));
  }
}
```

#### 4.2.4 å‰ç«¯ä¼˜åŒ–

```tsx
// frontend/admin/src/pages/Tickets/IntelligentTicketList.tsx

const IntelligentTicketList: React.FC = () => {
  const [tickets, setTickets] = useState([]);
  const [filters, setFilters] = useState({});
  const [autoReplyEnabled, setAutoReplyEnabled] = useState(true);

  // å·¥å•åˆ—è¡¨åˆ—å®šä¹‰
  const columns = [
    {
      title: 'å·¥å•ID',
      dataIndex: 'id',
      key: 'id',
      width: 100,
    },
    {
      title: 'æ ‡é¢˜',
      dataIndex: 'title',
      key: 'title',
      render: (title, record) => (
        <Space direction="vertical" size={0}>
          <a onClick={() => viewTicket(record.id)}>{title}</a>
          {record.classification?.suggestedTags.map((tag, idx) => (
            <Tag key={idx} size="small">{tag}</Tag>
          ))}
        </Space>
      ),
    },
    {
      title: 'ç±»åˆ«',
      dataIndex: ['classification', 'category'],
      key: 'category',
      render: (category) => getCategoryTag(category),
      filters: Object.values(TicketCategory).map(c => ({ text: c, value: c })),
      onFilter: (value, record) => record.classification.category === value,
    },
    {
      title: 'ä¼˜å…ˆçº§',
      dataIndex: ['classification', 'priority'],
      key: 'priority',
      render: (priority) => getPriorityBadge(priority),
      sorter: (a, b) => priorityOrder[a.classification.priority] - priorityOrder[b.classification.priority],
    },
    {
      title: 'çŠ¶æ€',
      dataIndex: 'status',
      key: 'status',
      render: (status) => getStatusTag(status),
    },
    {
      title: 'è‡ªåŠ¨å›å¤',
      dataIndex: ['classification', 'autoResolvable'],
      key: 'autoResolvable',
      render: (autoResolvable) => (
        autoResolvable ? (
          <Tag color="green" icon={<CheckCircleOutlined />}>
            å·²è‡ªåŠ¨å›å¤
          </Tag>
        ) : (
          <Tag color="gray">éœ€äººå·¥å¤„ç†</Tag>
        )
      ),
    },
    {
      title: 'å¤„ç†äºº',
      dataIndex: 'assigneeName',
      key: 'assigneeName',
      render: (name, record) => (
        <Space>
          <Avatar size="small">{name?.[0]}</Avatar>
          <span>{name || 'æœªåˆ†é…'}</span>
        </Space>
      ),
    },
    {
      title: 'å“åº”æ—¶é—´',
      dataIndex: 'responseTime',
      key: 'responseTime',
      render: (time) => (
        <span style={{ color: time > 30 ? 'red' : 'green' }}>
          {time ? `${time}åˆ†é’Ÿ` : '-'}
        </span>
      ),
      sorter: (a, b) => a.responseTime - b.responseTime,
    },
    {
      title: 'åˆ›å»ºæ—¶é—´',
      dataIndex: 'createdAt',
      key: 'createdAt',
      render: (date) => moment(date).fromNow(),
    },
    {
      title: 'æ“ä½œ',
      key: 'action',
      render: (_, record) => (
        <Space>
          <Button size="small" onClick={() => viewTicket(record.id)}>æŸ¥çœ‹</Button>
          {record.status === TicketStatus.OPEN && (
            <Button size="small" type="primary" onClick={() => assignToMe(record.id)}>
              æ¥æ‰‹
            </Button>
          )}
        </Space>
      ),
    },
  ];

  return (
    <div>
      {/* ç­›é€‰å™¨ */}
      <Card style={{ marginBottom: 16 }}>
        <Space>
          <Select
            placeholder="é€‰æ‹©ç±»åˆ«"
            style={{ width: 150 }}
            onChange={(value) => setFilters({ ...filters, category: value })}
            allowClear
          >
            {Object.values(TicketCategory).map(c => (
              <Option key={c} value={c}>{c}</Option>
            ))}
          </Select>

          <Select
            placeholder="é€‰æ‹©ä¼˜å…ˆçº§"
            style={{ width: 150 }}
            onChange={(value) => setFilters({ ...filters, priority: value })}
            allowClear
          >
            {Object.values(TicketPriority).map(p => (
              <Option key={p} value={p}>{p}</Option>
            ))}
          </Select>

          <Select
            placeholder="é€‰æ‹©çŠ¶æ€"
            style={{ width: 150 }}
            onChange={(value) => setFilters({ ...filters, status: value })}
            allowClear
          >
            {Object.values(TicketStatus).map(s => (
              <Option key={s} value={s}>{s}</Option>
            ))}
          </Select>

          <Switch
            checked={autoReplyEnabled}
            onChange={setAutoReplyEnabled}
            checkedChildren="è‡ªåŠ¨å›å¤å¼€å¯"
            unCheckedChildren="è‡ªåŠ¨å›å¤å…³é—­"
          />

          <Button onClick={() => refreshTickets()}>åˆ·æ–°</Button>
        </Space>
      </Card>

      {/* å·¥å•è¡¨æ ¼ */}
      <Card>
        <Table
          columns={columns}
          dataSource={tickets}
          rowKey="id"
          pagination={{
            pageSize: 20,
            showTotal: (total) => `å…± ${total} ä¸ªå·¥å•`,
          }}
        />
      </Card>
    </div>
  );
};
```

---

## 5. å®æ–½è·¯çº¿å›¾

### æ€»ä½“æ—¶é—´è§„åˆ’ï¼š8-10 å‘¨

| é˜¶æ®µ | æ—¶é—´ | ä»»åŠ¡ | é¢„æœŸæˆæœ |
|------|------|------|---------|
| **é˜¶æ®µ 1** | ç¬¬ 1-2 å‘¨ | å¥åº·åº¦è¯„åˆ†ç³»ç»ŸåŸºç¡€è®¾æ–½ | æ•°æ®åº“ã€æ ¸å¿ƒæœåŠ¡å®Œæˆ |
| **é˜¶æ®µ 2** | ç¬¬ 3-4 å‘¨ | å¥åº·åº¦è®¡ç®—é€»è¾‘ + æ™ºèƒ½è¿ç»´è‡ªåŠ¨åŒ–å¢å¼º | è¯„åˆ†ç®—æ³•ã€è‡ªåŠ¨ä¿®å¤å¼•æ“å®Œæˆ |
| **é˜¶æ®µ 3** | ç¬¬ 5-6 å‘¨ | æˆæœ¬ä¼˜åŒ–ç³»ç»Ÿ + å·¥å•ç³»ç»Ÿä¼˜åŒ– | æˆæœ¬åˆ†æã€æ™ºèƒ½è·¯ç”±å®Œæˆ |
| **é˜¶æ®µ 4** | ç¬¬ 7-8 å‘¨ | å‰ç«¯å¼€å‘ + é›†æˆæµ‹è¯• | æ‰€æœ‰å‰ç«¯é¡µé¢å®Œæˆ |
| **é˜¶æ®µ 5** | ç¬¬ 9-10 å‘¨ | ç°åº¦å‘å¸ƒ + ä¼˜åŒ–è¿­ä»£ | å…¨é‡ä¸Šçº¿ |

### ä¼˜å…ˆçº§å»ºè®®

**P0ï¼ˆå¿…é¡»å®Œæˆï¼‰ï¼š**
1. å¥åº·åº¦è¯„åˆ†ä¸é¢„è­¦ç³»ç»Ÿï¼ˆç”¨æˆ·ç•™å­˜çš„å…³é”®ï¼‰
2. æ™ºèƒ½è¿ç»´è‡ªåŠ¨åŒ–ï¼ˆå‡å°‘è¿ç»´æˆæœ¬ï¼‰

**P1ï¼ˆé‡è¦ï¼‰ï¼š**
3. æˆæœ¬ä¸å®¹é‡ä¼˜åŒ–ç³»ç»Ÿï¼ˆæå‡å¹³å°ç›ˆåˆ©èƒ½åŠ›ï¼‰
4. å·¥å•æ™ºèƒ½åˆ†ç±»ä¸è‡ªåŠ¨å›å¤ï¼ˆæå‡ç”¨æˆ·æ»¡æ„åº¦ï¼‰

**P2ï¼ˆå¢å¼ºï¼‰ï¼š**
5. çŸ¥è¯†åº“å­¦ä¹ ç³»ç»Ÿ
6. å®¹é‡è§„åˆ’ä¸é¢„æµ‹

### èµ„æºéœ€æ±‚

**å¼€å‘èµ„æºï¼š**
- åç«¯å¼€å‘ï¼š2 äºº Ã— 10 å‘¨
- å‰ç«¯å¼€å‘ï¼š1 äºº Ã— 4 å‘¨
- æµ‹è¯•ï¼š1 äºº Ã— 2 å‘¨

**åŸºç¡€è®¾æ–½ï¼š**
- PostgreSQL å­˜å‚¨æ‰©å®¹
- Redis ç¼“å­˜æ‰©å®¹
- Prometheus ç›‘æ§å¢å¼º

**ç¬¬ä¸‰æ–¹æœåŠ¡ï¼ˆå¯é€‰ï¼‰ï¼š**
- AI/NLP APIï¼ˆç”¨äºå·¥å•æ™ºèƒ½åˆ†ç±»å’Œ FAQ åŒ¹é…ï¼‰
- é‚®ä»¶/çŸ­ä¿¡æœåŠ¡ï¼ˆå·²æœ‰ï¼Œéœ€ç¡®ä¿å®¹é‡ï¼‰

---

## æ€»ç»“

æœ¬æ–¹æ¡ˆæä¾›äº†å››ä¸ªè¿è¥ä¼˜åŒ–é¢†åŸŸçš„è¯¦ç»†å®æ–½è®¡åˆ’ï¼š

1. **å¥åº·åº¦è¯„åˆ†ä¸é¢„è­¦ç³»ç»Ÿ**ï¼šé€šè¿‡å¤šç»´åº¦è¯„åˆ†æ¨¡å‹ï¼Œæå‰è¯†åˆ«æµå¤±é£é™©ç”¨æˆ·ï¼Œä¸»åŠ¨å¹²é¢„æå‡ç•™å­˜ç‡ã€‚

2. **æ™ºèƒ½è¿ç»´è‡ªåŠ¨åŒ–å¢å¼º**ï¼šåŸºäº Prometheus å‘Šè­¦çš„è‡ªåŠ¨ä¿®å¤å¼•æ“ï¼Œå‡å°‘äººå·¥è¿ç»´æˆæœ¬ï¼Œæé«˜æ•…éšœå“åº”é€Ÿåº¦ã€‚

3. **æˆæœ¬ä¸å®¹é‡ä¼˜åŒ–ç³»ç»Ÿ**ï¼šå®æ—¶æˆæœ¬ç›‘æ§ã€å¼‚å¸¸æ£€æµ‹ã€ä¼˜åŒ–å»ºè®®å¼•æ“ï¼Œå¸®åŠ©ç”¨æˆ·å’Œå¹³å°é™ä½è¿è¥æˆæœ¬ã€‚

4. **å·¥å•ä¸æ”¯æŒç³»ç»Ÿä¼˜åŒ–**ï¼šæ™ºèƒ½åˆ†ç±»è·¯ç”±ã€è‡ªåŠ¨å›å¤ã€çŸ¥è¯†åº“å­¦ä¹ ï¼Œæå‡å·¥å•å¤„ç†æ•ˆç‡å’Œç”¨æˆ·æ»¡æ„åº¦ã€‚

æ‰€æœ‰æ–¹æ¡ˆå‡åŸºäºæ‚¨ç°æœ‰çš„æŠ€æœ¯æ ˆï¼ˆNestJSã€PostgreSQLã€Redisã€RabbitMQã€Prometheusï¼‰ï¼Œå¯ä»¥æ— ç¼é›†æˆåˆ°ç°æœ‰æ¶æ„ä¸­ï¼Œæ— éœ€å¼•å…¥é¢å¤–çš„å¤æ‚æŠ€æœ¯ã€‚

**ä¸‹ä¸€æ­¥è¡ŒåŠ¨ï¼š**
å¦‚æœæ‚¨åŒæ„ä¸Šè¿°æ–¹æ¡ˆï¼Œæˆ‘å¯ä»¥ç«‹å³å¼€å§‹å®æ–½ã€‚è¯·å‘Šè¯‰æˆ‘æ‚¨å¸Œæœ›å…ˆä»å“ªä¸ªæ¨¡å—å¼€å§‹ï¼ˆå»ºè®®ä»å¥åº·åº¦è¯„åˆ†ç³»ç»Ÿå¼€å§‹ï¼Œå› ä¸ºå®ƒå¯¹ç”¨æˆ·ç•™å­˜å½±å“æœ€å¤§ï¼‰ã€‚
