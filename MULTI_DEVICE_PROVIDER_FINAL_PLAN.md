# å¤šè®¾å¤‡æºäº‘æ‰‹æœºå¹³å°ç»Ÿä¸€å¯¹æ¥æ–¹æ¡ˆ (æœ€ç»ˆç‰ˆ)

**æ–‡æ¡£ç‰ˆæœ¬**: v2.0
**æ›´æ–°æ—¶é—´**: 2025-10-28
**é¡¹ç›®**: Cloud Phone Platform - å¤šè®¾å¤‡æºç»Ÿä¸€ç®¡ç†
**çŠ¶æ€**: å¾…ç¡®è®¤

---

## ğŸ“‹ æ‰§è¡Œæ‘˜è¦

### æ ¸å¿ƒç›®æ ‡

å®ç°ç»Ÿä¸€è®¾å¤‡æä¾›å•†æŠ½è±¡å±‚,æ”¯æŒå››ç§è®¾å¤‡æº:
1. **ç‰©ç†è®¾å¤‡ (1000+ å°)** - ğŸ”´ **æœ€é«˜ä¼˜å…ˆçº§**
2. **åä¸ºäº‘æ‰‹æœº CPH** - ğŸŸ¡ ç¬¬äºŒä¼˜å…ˆçº§
3. **é˜¿é‡Œäº‘ ECP** - ğŸŸ¡ ç¬¬äºŒä¼˜å…ˆçº§
4. **Redroid (ç°æœ‰)** - ğŸŸ¢ ä¿æŒå…¼å®¹

### éœ€æ±‚ç¡®è®¤

| éœ€æ±‚é¡¹ | ç¡®è®¤ç»“æœ |
|--------|---------|
| **ä¼˜å…ˆçº§** | ç‰©ç†è®¾å¤‡ç¬¬ä¸€,äº‘æ‰‹æœºç¬¬äºŒ |
| **æµ‹è¯•è´¦å·** | åä¸º + é˜¿é‡Œäº‘éƒ½æœ‰ âœ… |
| **ç‰©ç†è®¾å¤‡è§„æ¨¡** | **1000+ å°** (å¤§è§„æ¨¡éƒ¨ç½²) |
| **äº‘æ‰‹æœºæ”¯æŒ** | åä¸º + é˜¿é‡Œäº‘åŒæ—¶æ”¯æŒ |
| **ä¸Šçº¿æ—¶é—´** | â“ **å¾…ç¡®è®¤** |

### å…³é”®è°ƒæ•´

**åŸæ–¹æ¡ˆé—®é¢˜**: ç‰©ç†è®¾å¤‡æ–¹æ¡ˆæŒ‰ 10-100 å°è§„æ¨¡è®¾è®¡,ä¸é€‚ç”¨äº 1000+ å°

**è°ƒæ•´å†…å®¹**:
- âœ… Phase 2 æ‹†åˆ†ä¸º **2A (åŸºç¡€)** + **2B (å¤§è§„æ¨¡ä¼˜åŒ–)**
- âœ… å¢åŠ è®¾å¤‡æ± åˆ†ç‰‡ç®¡ç†
- âœ… å¢åŠ åˆ†å¸ƒå¼è®¾å¤‡å‘ç°
- âœ… å¢åŠ è®¾å¤‡å¥åº·è¯„åˆ†å’Œè‡ªåŠ¨å‰”é™¤
- âœ… å¢åŠ è´Ÿè½½å‡è¡¡å’Œæ™ºèƒ½è°ƒåº¦

---

## ğŸ¯ æŠ€æœ¯æ–¹æ¡ˆæ€»è§ˆ

### æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              å‰ç«¯ (Admin + User Portal)                  â”‚
â”‚   - è®¾å¤‡åˆ—è¡¨ (æŒ‰æä¾›å•†/åœ°åŸŸ/å‹å·åˆ†ç»„)                      â”‚
â”‚   - è®¾å¤‡æ± ç®¡ç† (1000+ å°å¯è§†åŒ–)                           â”‚
â”‚   - åˆ›å»ºè®¾å¤‡ (æ™ºèƒ½è°ƒåº¦)                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚ REST API
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Device Service                              â”‚
â”‚         (ç»Ÿä¸€è®¾å¤‡ç¼–æ’å’Œç”Ÿå‘½å‘¨æœŸç®¡ç†)                       â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚   DeviceProviderFactory (æä¾›å•†å·¥å‚)            â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚         â”‚          â”‚          â”‚          â”‚              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”  â”Œâ”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ–¼â”€â”€â”€â”€â”€â”  â”Œâ–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Physical â”‚  â”‚ Redroid â”‚  â”‚Huaweiâ”‚  â”‚  Aliyun   â”‚  â”‚
â”‚  â”‚ Provider â”‚  â”‚Provider â”‚  â”‚ CPH  â”‚  â”‚   ECP     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Physical Device Manager (ç‰©ç†è®¾å¤‡ç®¡ç†å±‚)           â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Device Pool  â”‚  â”‚   Device    â”‚  â”‚    Device      â”‚ â”‚
â”‚  â”‚  Sharding    â”‚  â”‚  Discovery  â”‚  â”‚    Health      â”‚ â”‚
â”‚  â”‚  (åˆ†ç‰‡ç®¡ç†)   â”‚  â”‚  (å‘ç°)      â”‚  â”‚   Monitor      â”‚ â”‚
â”‚  â”‚              â”‚  â”‚             â”‚  â”‚  (å¥åº·ç›‘æ§)     â”‚ â”‚
â”‚  â”‚ Shard 1:     â”‚  â”‚ - Network   â”‚  â”‚                â”‚ â”‚
â”‚  â”‚   Device     â”‚  â”‚   Scan      â”‚  â”‚ - 30så¿ƒè·³      â”‚ â”‚
â”‚  â”‚   1-500      â”‚  â”‚ - ADB List  â”‚  â”‚ - å¥åº·è¯„åˆ†     â”‚ â”‚
â”‚  â”‚              â”‚  â”‚ - mDNS      â”‚  â”‚ - è‡ªåŠ¨å‰”é™¤     â”‚ â”‚
â”‚  â”‚ Shard 2:     â”‚  â”‚   Discover  â”‚  â”‚ - æ•…éšœæ¢å¤     â”‚ â”‚
â”‚  â”‚   Device     â”‚  â”‚             â”‚  â”‚                â”‚ â”‚
â”‚  â”‚   501-1000   â”‚  â”‚             â”‚  â”‚                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Device Scheduler (æ™ºèƒ½è°ƒåº¦å™¨)                   â”‚  â”‚
â”‚  â”‚   - è´Ÿè½½å‡è¡¡ (æŒ‰è®¾å¤‡å¥åº·åº¦ã€ä½¿ç”¨ç‡)                 â”‚  â”‚
â”‚  â”‚   - äº²å’Œæ€§è°ƒåº¦ (ç”¨æˆ·æŒ‡å®šå‹å·/Androidç‰ˆæœ¬)           â”‚  â”‚
â”‚  â”‚   - åœ°åŸŸå°±è¿‘ (å¦‚æœè·¨åœ°åŸŸéƒ¨ç½²)                       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            1000+ Physical Devices                        â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚Device 1â”‚  â”‚Device 2â”‚  â”‚Device 3â”‚  ...  â”‚Device  â”‚  â”‚
â”‚  â”‚Xiaomi  â”‚  â”‚Samsung â”‚  â”‚Huawei  â”‚       â”‚1000+   â”‚  â”‚
â”‚  â”‚Android â”‚  â”‚Android â”‚  â”‚Android â”‚       â”‚        â”‚  â”‚
â”‚  â”‚  12    â”‚  â”‚  13    â”‚  â”‚  11    â”‚       â”‚        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  Network ADB: <IP>:5555                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Media Service                                â”‚
â”‚        (WebRTC è§†é¢‘æµ + SCRCPY é«˜æ€§èƒ½æŠ•å±)                â”‚
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚   CaptureFactory (é‡‡é›†å™¨å·¥å‚)                   â”‚    â”‚
â”‚  â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚     â”‚          â”‚          â”‚          â”‚                  â”‚
â”‚  â”Œâ”€â”€â–¼â”€â”€â”€â”  â”Œâ”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â–¼â”€â”€â”€â”€â”€â”  â”Œâ–¼â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚SCRCPYâ”‚  â”‚  ADB  â”‚  â”‚ Huawei â”‚  â”‚ Aliyun  â”‚        â”‚
â”‚  â”‚é«˜æ€§èƒ½â”‚  â”‚Screen â”‚  â”‚ Stream â”‚  â”‚ WebRTC  â”‚        â”‚
â”‚  â”‚35-70msâ”‚  â”‚Record â”‚  â”‚ Captureâ”‚  â”‚ Bridge  â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚     â”‚          â”‚          â”‚          â”‚                  â”‚
â”‚  â”Œâ”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚   Unified Encoder Pipeline                  â”‚       â”‚
â”‚  â”‚   - H.264 ç¡¬ä»¶åŠ é€Ÿ                           â”‚       â”‚
â”‚  â”‚   - Worker Pool å¹¶å‘ç¼–ç                      â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸš€ å®æ–½è·¯çº¿å›¾ (è°ƒæ•´ç‰ˆ)

### æ€»æ—¶é—´: 11 å‘¨ (åŸ 9 å‘¨)

| é˜¶æ®µ | æ—¶é—´ | ä¼˜å…ˆçº§ | äº¤ä»˜å†…å®¹ |
|------|------|--------|---------|
| **Phase 1: åŸºç¡€æ¶æ„** | Week 1-2 | ğŸ”´ å¿…é¡» | æä¾›å•†æŠ½è±¡å±‚,Redroidå°è£… |
| **Phase 2A: ç‰©ç†è®¾å¤‡åŸºç¡€** | Week 3-4 | ğŸ”´ æœ€é«˜ | è®¾å¤‡æ± ,ADBè¿æ¥,SCRCPYæŠ•å± |
| **Phase 2B: ç‰©ç†è®¾å¤‡å¤§è§„æ¨¡** | Week 5-6 | ğŸ”´ æœ€é«˜ | åˆ†ç‰‡ç®¡ç†,æ™ºèƒ½è°ƒåº¦,1000+å°æ”¯æŒ |
| **Phase 3: åä¸ºäº‘æ‰‹æœº** | Week 7-8 | ğŸŸ¡ ç¬¬äºŒ | åä¸º CPH API å¯¹æ¥ |
| **Phase 4: é˜¿é‡Œäº‘æ‰‹æœº** | Week 9-10 | ğŸŸ¡ ç¬¬äºŒ | é˜¿é‡Œäº‘ ECP API å¯¹æ¥ |
| **Phase 5: ç›‘æ§ä¼˜åŒ–** | Week 11 | ğŸŸ¢ æ”¶å°¾ | ç›‘æ§å‘Šè­¦,æ€§èƒ½ä¼˜åŒ– |

---

## ğŸ“… Phase 1: åŸºç¡€æ¶æ„ (Week 1-2)

### ç›®æ ‡

å¼•å…¥è®¾å¤‡æä¾›å•†æŠ½è±¡å±‚,å°è£…ç°æœ‰ Redroid,ä¸ºå¤šè®¾å¤‡æºæ‰“åŸºç¡€ã€‚

### ä»»åŠ¡æ¸…å•

#### 1.1 æ ¸å¿ƒæ¥å£å®šä¹‰ (3 å¤©) âœ… **å·²å®Œæˆ**

**å·²åˆ›å»ºæ–‡ä»¶**:
- âœ… `src/providers/provider.types.ts` - ç±»å‹å®šä¹‰
- âœ… `src/providers/device-provider.interface.ts` - æä¾›å•†æ¥å£

**åŒ…å«å†…å®¹**:
- `IDeviceProvider` æ¥å£ (23ä¸ªæ–¹æ³•)
- `DeviceProviderType` æšä¸¾ (4ç§è®¾å¤‡æº)
- `ConnectionInfo` ç»Ÿä¸€è¿æ¥ä¿¡æ¯
- `DeviceCapabilities` èƒ½åŠ›æè¿°
- æ§åˆ¶äº‹ä»¶å®šä¹‰ (è§¦æ‘¸ã€æ»‘åŠ¨ã€æŒ‰é”®ç­‰)

---

#### 1.2 æ•°æ®åº“æ‰©å±• (2 å¤©)

**ä¿®æ”¹æ–‡ä»¶**:
- `src/entities/device.entity.ts`

**æ–°å¢å­—æ®µ**:
```typescript
@Column({
  type: 'enum',
  enum: DeviceProviderType,
  default: DeviceProviderType.REDROID,
})
providerType: DeviceProviderType;

@Column({ type: 'jsonb', nullable: true })
providerConfig: Record<string, any>; // æä¾›å•†ç‰¹å®šé…ç½®

@Column({ type: 'jsonb', nullable: true })
connectionInfo: ConnectionInfo; // ç¼“å­˜çš„è¿æ¥ä¿¡æ¯

// ç‰©ç†è®¾å¤‡ç‰¹å®šå­—æ®µ
@Column({ type: 'varchar', nullable: true })
deviceGroup?: string; // è®¾å¤‡åˆ†ç»„ (æŒ‰å‹å·/åœ°åŸŸ)

@Column({ type: 'varchar', nullable: true })
deviceTags?: string; // è®¾å¤‡æ ‡ç­¾ (é€—å·åˆ†éš”)

@Column({ type: 'int', default: 100 })
healthScore: number; // å¥åº·è¯„åˆ† (0-100)

@Column({ type: 'timestamp', nullable: true })
lastHeartbeatAt?: Date; // æœ€åå¿ƒè·³æ—¶é—´
```

**Atlas è¿ç§»è„šæœ¬**:
```bash
cd backend/device-service

# ç”Ÿæˆè¿ç§»
atlas migrate diff add_provider_fields \
  --dir "file://migrations" \
  --to "ent://src/entities" \
  --dev-url "docker://postgres/15/dev?search_path=public"

# åº”ç”¨è¿ç§»
pnpm migrate:apply
```

**SQL é¢„è§ˆ**:
```sql
-- æ·»åŠ æä¾›å•†å­—æ®µ
ALTER TABLE devices
  ADD COLUMN provider_type VARCHAR(20) DEFAULT 'redroid',
  ADD COLUMN provider_config JSONB,
  ADD COLUMN connection_info JSONB,
  ADD COLUMN device_group VARCHAR(50),
  ADD COLUMN device_tags VARCHAR(200),
  ADD COLUMN health_score INT DEFAULT 100,
  ADD COLUMN last_heartbeat_at TIMESTAMP;

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_devices_provider_type ON devices(provider_type);
CREATE INDEX idx_devices_health_score ON devices(health_score);
CREATE INDEX idx_devices_device_group ON devices(device_group);
CREATE INDEX idx_devices_last_heartbeat ON devices(last_heartbeat_at);

-- ä¸ºç°æœ‰æ•°æ®è®¾ç½®é»˜è®¤å€¼
UPDATE devices SET provider_type = 'redroid' WHERE provider_type IS NULL;
```

---

#### 1.3 æä¾›å•†å·¥å‚ (2 å¤©)

**æ–°å»ºæ–‡ä»¶**:
- `src/providers/device-provider.factory.ts`
- `src/providers/providers.module.ts`

**å·¥å‚å®ç°**:
```typescript
@Injectable()
export class DeviceProviderFactory implements IDeviceProviderFactory {
  private providers = new Map<DeviceProviderType, IDeviceProvider>();

  constructor(
    private readonly logger: Logger,
    private readonly configService: ConfigService,
  ) {}

  onModuleInit() {
    // åç»­åœ¨è¿™é‡Œæ³¨å†Œå„ä¸ª Provider
  }

  getProvider(type: DeviceProviderType): IDeviceProvider {
    const provider = this.providers.get(type);
    if (!provider) {
      throw new Error(`Provider ${type} not found or not enabled`);
    }
    return provider;
  }

  registerProvider(provider: IDeviceProvider): void {
    this.logger.log(`Registering provider: ${provider.providerType}`);
    this.providers.set(provider.providerType, provider);
  }

  getAllProviders(): IDeviceProvider[] {
    return Array.from(this.providers.values());
  }

  isProviderAvailable(type: DeviceProviderType): boolean {
    return this.providers.has(type);
  }
}
```

---

#### 1.4 å°è£… Redroid ä¸º Provider (4 å¤©)

**æ–°å»ºæ–‡ä»¶**:
- `src/providers/redroid/redroid.provider.ts`
- `src/providers/redroid/redroid.module.ts`

**å®ç°è¦ç‚¹**:
```typescript
@Injectable()
export class RedroidProvider implements IDeviceProvider {
  readonly providerType = DeviceProviderType.REDROID;

  constructor(
    private readonly dockerService: DockerService,
    private readonly adbService: AdbService,
    private readonly portManager: PortManagerService,
    private readonly logger: Logger,
  ) {}

  async create(config: DeviceCreateConfig): Promise<ProviderDevice> {
    // 1. åˆ†é… ADB ç«¯å£
    const adbPort = await this.portManager.allocatePort();

    // 2. åˆ›å»º Redroid å®¹å™¨ (å¤ç”¨ç°æœ‰ DockerService é€»è¾‘)
    const container = await this.dockerService.createContainer({
      name: `redroid-${config.name}`,
      cpuCores: config.cpuCores,
      memoryMB: config.memoryMB,
      resolution: `${config.resolution.width}x${config.resolution.height}`,
      adbPort: adbPort,
      // ... å…¶ä»–é…ç½®
    });

    // 3. ç­‰å¾… ADB å°±ç»ª
    await this.adbService.waitForDevice(`localhost:${adbPort}`, 30000);

    return {
      deviceId: container.id,
      providerConfig: {
        containerId: container.id,
        containerName: container.name,
        adbPort: adbPort,
      },
    };
  }

  async getConnectionInfo(deviceId: string): Promise<ConnectionInfo> {
    // ä» providerConfig è¯»å– adbPort
    const device = await this.getDeviceFromDb(deviceId);
    const config = device.providerConfig as any;

    return {
      providerType: DeviceProviderType.REDROID,
      adb: {
        host: 'localhost',
        port: config.adbPort,
        serial: `localhost:${config.adbPort}`,
      },
    };
  }

  getCapabilities(): DeviceCapabilities {
    return {
      supportsAdb: true,
      supportsScreenCapture: true,
      supportsAudioCapture: true,
      supportedCaptureFormats: [
        CaptureFormat.SCREENCAP,
        CaptureFormat.SCREENRECORD,
      ],
      maxResolution: { width: 1920, height: 1080 },
      supportsTouchControl: true,
      supportsKeyboardInput: true,
      supportsFileTransfer: true,
      supportsAppInstall: true,
      supportsSensorSimulation: true,
      supportsCamera: false,
      supportsMicrophone: false,
      supportsBatterySimulation: false,
    };
  }

  // å…¶ä»–æ–¹æ³•: start, stop, destroy ç­‰
  // ...
}
```

---

#### 1.5 æ›´æ–° DevicesService (3 å¤©)

**ä¿®æ”¹æ–‡ä»¶**:
- `src/devices/devices.service.ts`
- `src/devices/devices.controller.ts`
- `src/devices/dto/create-device.dto.ts`

**æ ¸å¿ƒæ”¹åŠ¨**:
```typescript
@Injectable()
export class DevicesService {
  constructor(
    private readonly providerFactory: DeviceProviderFactory,
    @InjectRepository(Device) private readonly devicesRepo: Repository<Device>,
    private readonly eventBus: EventBusService,
    private readonly logger: Logger,
  ) {}

  async create(dto: CreateDeviceDto): Promise<Device> {
    // 1. è·å–æä¾›å•† (é»˜è®¤ Redroid)
    const providerType = dto.providerType || DeviceProviderType.REDROID;
    const provider = this.providerFactory.getProvider(providerType);

    this.logger.log(`Creating device with provider: ${providerType}`);

    // 2. åˆ›å»ºè®¾å¤‡å®ä¾‹
    const instance = await provider.create({
      name: dto.name,
      userId: dto.userId,
      cpuCores: dto.cpuCores,
      memoryMB: dto.memoryMB,
      resolution: dto.resolution,
      androidVersion: dto.androidVersion,
      deviceType: dto.type,
    });

    // 3. è·å–è¿æ¥ä¿¡æ¯
    const connectionInfo = await provider.getConnectionInfo(instance.deviceId);

    // 4. ä¿å­˜è®¾å¤‡è®°å½•
    const device = this.devicesRepo.create({
      ...dto,
      providerType: providerType,
      providerConfig: instance.providerConfig,
      connectionInfo: connectionInfo,
      healthScore: 100, // æ–°è®¾å¤‡æ»¡åˆ†
      status: DeviceStatus.CREATING,
    });

    await this.devicesRepo.save(device);

    // 5. å¯åŠ¨è®¾å¤‡
    try {
      await provider.start(instance.deviceId);
      device.status = DeviceStatus.RUNNING;
      await this.devicesRepo.save(device);
    } catch (error) {
      device.status = DeviceStatus.ERROR;
      await this.devicesRepo.save(device);
      throw error;
    }

    // 6. å‘å¸ƒäº‹ä»¶
    await this.eventBus.publishDeviceEvent('created', {
      deviceId: device.id,
      providerType: providerType,
    });

    return device;
  }

  // æ–°å¢: ä¾› Media Service ä½¿ç”¨
  async getStreamInfo(deviceId: string) {
    const device = await this.findOne(deviceId);
    const provider = this.providerFactory.getProvider(device.providerType);

    return {
      deviceId: device.id,
      providerType: device.providerType,
      connectionInfo: await provider.getConnectionInfo(device.id),
      capabilities: provider.getCapabilities(),
    };
  }
}
```

**DTO æ›´æ–°**:
```typescript
export class CreateDeviceDto {
  // ... ç°æœ‰å­—æ®µ

  @IsOptional()
  @IsEnum(DeviceProviderType)
  providerType?: DeviceProviderType; // æ–°å¢: æä¾›å•†ç±»å‹
}
```

---

#### 1.6 é›†æˆæµ‹è¯• (2 å¤©)

**æµ‹è¯•å†…å®¹**:
- âœ… Redroid è®¾å¤‡åˆ›å»ºåŠŸèƒ½ (100% å…¼å®¹æµ‹è¯•)
- âœ… æä¾›å•†å·¥å‚æ³¨å†Œå’Œè·å–
- âœ… æ•°æ®åº“è¿ç§»éªŒè¯
- âœ… API ç«¯ç‚¹æµ‹è¯• (`POST /devices` æ”¯æŒ providerType)
- âœ… è¿æ¥ä¿¡æ¯è·å– (`GET /devices/:id/stream-info`)

**éªŒæ”¶æ ‡å‡†**:
- ç°æœ‰ Redroid åŠŸèƒ½ 100% æ­£å¸¸
- å•å…ƒæµ‹è¯•è¦†ç›–ç‡ >70%
- æ‰€æœ‰ API æµ‹è¯•é€šè¿‡

---

## ğŸ“± Phase 2A: ç‰©ç†è®¾å¤‡åŸºç¡€ (Week 3-4)

### ç›®æ ‡

æ”¯æŒç‰©ç†è®¾å¤‡è¿æ¥ (10-100 å°è§„æ¨¡),å®ç° SCRCPY é«˜æ€§èƒ½æŠ•å±ã€‚

### ä»»åŠ¡æ¸…å•

#### 2A.1 ç‰©ç†è®¾å¤‡ç®¡ç†æœåŠ¡ (4 å¤©)

**æ–°å»ºæ–‡ä»¶**:
- `src/providers/physical/physical-device.manager.ts`
- `src/providers/physical/physical.provider.ts`
- `src/providers/physical/physical.module.ts`

**è®¾å¤‡æ± ç®¡ç†**:
```typescript
export interface PhysicalDevice {
  serial: string; // ADB åºåˆ—å· (å¦‚ 192.168.1.100:5555)
  model: string;
  manufacturer: string;
  androidVersion: string;
  connectionType: 'wifi' | 'usb';
  status: 'available' | 'allocated' | 'offline';
  healthScore: number;
  lastHeartbeatAt: Date;

  // æ‰©å±•å±æ€§
  deviceGroup?: string; // è®¾å¤‡åˆ†ç»„
  tags?: string[];      // æ ‡ç­¾
  location?: string;    // åœ°ç†ä½ç½®
}

@Injectable()
export class PhysicalDeviceManager {
  private devices = new Map<string, PhysicalDevice>();

  constructor(
    private readonly adbService: AdbService,
    private readonly logger: Logger,
  ) {}

  // è‡ªåŠ¨å‘ç° ADB è®¾å¤‡
  async discoverDevices(): Promise<PhysicalDevice[]> {
    const adbDevices = await this.adbService.listDevices();

    const discovered: PhysicalDevice[] = [];

    for (const adbDevice of adbDevices) {
      if (!this.devices.has(adbDevice.serial)) {
        // æŸ¥è¯¢è®¾å¤‡å±æ€§
        const props = await this.adbService.getDeviceProperties(adbDevice.serial);

        const device: PhysicalDevice = {
          serial: adbDevice.serial,
          model: props['ro.product.model'],
          manufacturer: props['ro.product.manufacturer'],
          androidVersion: props['ro.build.version.release'],
          connectionType: adbDevice.serial.includes(':') ? 'wifi' : 'usb',
          status: 'available',
          healthScore: 100,
          lastHeartbeatAt: new Date(),
        };

        this.devices.set(device.serial, device);
        discovered.push(device);

        this.logger.log(`Discovered device: ${device.model} (${device.serial})`);
      }
    }

    return discovered;
  }

  // WiFi ADB è¿æ¥
  async connectWifi(ip: string, port: number = 5555): Promise<string> {
    const serial = `${ip}:${port}`;

    try {
      await this.adbService.connect(serial);
      await this.discoverDevices(); // é‡æ–°æ‰«æ
      return serial;
    } catch (error) {
      throw new Error(`Failed to connect to ${serial}: ${error.message}`);
    }
  }

  // å¥åº·æ£€æŸ¥ (30ç§’å®šæ—¶ä»»åŠ¡)
  @Cron('*/30 * * * * *')
  async healthCheck() {
    for (const [serial, device] of this.devices.entries()) {
      try {
        const state = await this.adbService.getDeviceState(serial);

        if (state === 'device') {
          device.status = device.status === 'offline' ? 'available' : device.status;
          device.healthScore = Math.min(100, device.healthScore + 5); // æ¢å¤å¥åº·åº¦
          device.lastHeartbeatAt = new Date();
        } else {
          device.status = 'offline';
          device.healthScore = Math.max(0, device.healthScore - 10);
        }
      } catch (error) {
        device.status = 'offline';
        device.healthScore = Math.max(0, device.healthScore - 10);
        this.logger.warn(`Device ${serial} health check failed`);
      }
    }
  }

  // åˆ†é…è®¾å¤‡ (æŒ‰å¥åº·åº¦å’Œå¯ç”¨æ€§)
  async allocateDevice(criteria?: {
    model?: string;
    androidVersion?: string;
    deviceGroup?: string;
  }): Promise<PhysicalDevice | null> {
    const available = Array.from(this.devices.values())
      .filter(d => d.status === 'available')
      .filter(d => d.healthScore > 50) // å¥åº·åº¦ > 50
      .filter(d => !criteria || (
        (!criteria.model || d.model === criteria.model) &&
        (!criteria.androidVersion || d.androidVersion === criteria.androidVersion) &&
        (!criteria.deviceGroup || d.deviceGroup === criteria.deviceGroup)
      ))
      .sort((a, b) => b.healthScore - a.healthScore); // æŒ‰å¥åº·åº¦æ’åº

    if (available.length === 0) {
      return null;
    }

    const device = available[0];
    device.status = 'allocated';

    return device;
  }

  // é‡Šæ”¾è®¾å¤‡
  async releaseDevice(serial: string): Promise<void> {
    const device = this.devices.get(serial);
    if (device) {
      device.status = 'available';
    }
  }

  // è·å–è®¾å¤‡æ± ç»Ÿè®¡
  getPoolStats() {
    const all = Array.from(this.devices.values());

    return {
      total: all.length,
      available: all.filter(d => d.status === 'available').length,
      allocated: all.filter(d => d.status === 'allocated').length,
      offline: all.filter(d => d.status === 'offline').length,
      avgHealthScore: all.reduce((sum, d) => sum + d.healthScore, 0) / all.length,
    };
  }
}
```

---

#### 2A.2 Physical Provider å®ç° (3 å¤©)

**æ ¸å¿ƒä»£ç **:
```typescript
@Injectable()
export class PhysicalProvider implements IDeviceProvider {
  readonly providerType = DeviceProviderType.PHYSICAL;

  constructor(
    private readonly deviceManager: PhysicalDeviceManager,
    private readonly adbService: AdbService,
    private readonly scrcpyService: ScrcpyService, // æ–°æœåŠ¡
    private readonly logger: Logger,
  ) {}

  async create(config: DeviceCreateConfig): Promise<ProviderDevice> {
    // ç‰©ç†è®¾å¤‡ä¸éœ€è¦"åˆ›å»º",è€Œæ˜¯ä»è®¾å¤‡æ± "åˆ†é…"
    const device = await this.deviceManager.allocateDevice({
      model: config.providerSpecificConfig?.model,
      androidVersion: config.androidVersion,
      deviceGroup: config.providerSpecificConfig?.deviceGroup,
    });

    if (!device) {
      throw new ProviderError(
        'No available physical device',
        DeviceProviderType.PHYSICAL,
        'NO_DEVICE_AVAILABLE',
      );
    }

    return {
      deviceId: device.serial,
      providerConfig: {
        serial: device.serial,
        model: device.model,
        manufacturer: device.manufacturer,
        androidVersion: device.androidVersion,
        connectionType: device.connectionType,
      },
    };
  }

  async getConnectionInfo(deviceId: string): Promise<ConnectionInfo> {
    const device = await this.deviceManager.getDevice(deviceId);

    // å¯åŠ¨ SCRCPY Server (é«˜æ€§èƒ½æŠ•å±)
    const scrcpyPort = await this.scrcpyService.startServer(deviceId);

    return {
      providerType: DeviceProviderType.PHYSICAL,
      adb: {
        host: device.connectionType === 'wifi' ? device.serial.split(':')[0] : 'localhost',
        port: device.connectionType === 'wifi' ? parseInt(device.serial.split(':')[1]) : 5037,
        serial: device.serial,
      },
      scrcpy: {
        host: 'localhost',
        port: scrcpyPort,
        maxBitrate: 8000000, // 8 Mbps
        codec: 'h264',
      },
    };
  }

  getCapabilities(): DeviceCapabilities {
    return {
      supportsAdb: true,
      supportsScreenCapture: true,
      supportsAudioCapture: true,
      supportedCaptureFormats: [
        CaptureFormat.SCRCPY,          // ä¼˜å…ˆ
        CaptureFormat.SCREENRECORD,
        CaptureFormat.SCREENCAP,
      ],
      maxResolution: { width: 1920, height: 1080 },
      supportsTouchControl: true,
      supportsKeyboardInput: true,
      supportsFileTransfer: true,
      supportsAppInstall: true,
      supportsSensorSimulation: false, // ç‰©ç†è®¾å¤‡æ— æ³•æ¨¡æ‹Ÿä¼ æ„Ÿå™¨
      supportsCamera: true,            // çœŸå®ç¡¬ä»¶
      supportsMicrophone: true,
      supportsBatterySimulation: false,
    };
  }

  async start(deviceId: string): Promise<void> {
    // ç‰©ç†è®¾å¤‡å·²è¿è¡Œ,è¿™é‡Œå¯ä»¥æ‰§è¡Œåˆå§‹åŒ–
    // ä¾‹å¦‚: æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    await this.adbService.executeCommand(deviceId, 'shell', ['rm', '-rf', '/sdcard/tmp/*']);
  }

  async stop(deviceId: string): Promise<void> {
    // åœæ­¢ SCRCPY Server
    await this.scrcpyService.stopServer(deviceId);

    // é‡Šæ”¾è®¾å¤‡å›æ± 
    await this.deviceManager.releaseDevice(deviceId);
  }

  async destroy(deviceId: string): Promise<void> {
    // ç‰©ç†è®¾å¤‡ä¸èƒ½é”€æ¯,åªèƒ½æ–­å¼€
    await this.deviceManager.disconnect(deviceId);
  }
}
```

---

#### 2A.3 SCRCPY æœåŠ¡é›†æˆ (4 å¤©)

**æ–°å»ºæ–‡ä»¶**:
- `src/providers/physical/scrcpy.service.ts`

**SCRCPY Server ç®¡ç†**:
```typescript
@Injectable()
export class ScrcpyService {
  private servers = new Map<string, ScrcpyServerInstance>();

  async startServer(deviceSerial: string): Promise<number> {
    // 1. åˆ†é…ç«¯å£
    const port = await this.allocatePort();

    // 2. æ¨é€ scrcpy-server.jar åˆ°è®¾å¤‡
    await this.adbService.push(
      deviceSerial,
      '/path/to/scrcpy-server.jar',
      '/data/local/tmp/scrcpy-server.jar'
    );

    // 3. å¯åŠ¨ server
    const proc = this.adbService.shell(deviceSerial, [
      'CLASSPATH=/data/local/tmp/scrcpy-server.jar',
      'app_process',
      '/',
      'com.genymobile.scrcpy.Server',
      '1.24',           // scrcpy ç‰ˆæœ¬
      'log_level=info',
      'max_size=0',
      'bit_rate=8000000',
      'max_fps=60',
      'tunnel_forward=true',
    ]);

    // 4. ç«¯å£è½¬å‘
    await this.adbService.forward(deviceSerial, port, 'localabstract:scrcpy');

    this.servers.set(deviceSerial, { port, proc });

    return port;
  }

  async stopServer(deviceSerial: string): Promise<void> {
    const server = this.servers.get(deviceSerial);
    if (server) {
      server.proc.kill();
      await this.adbService.removeForward(deviceSerial, server.port);
      this.servers.delete(deviceSerial);
    }
  }
}
```

**Media Service SCRCPY Capture** (Go):
```go
// backend/media-service/internal/capture/scrcpy_capture.go
type ScrcpyCapture struct {
    deviceSerial  string
    scrcpyHost    string
    scrcpyPort    int
    conn          net.Conn
    frameChannel  chan *Frame
    logger        *logrus.Logger
    running       atomic.Bool
}

func (c *ScrcpyCapture) Start(ctx context.Context, options CaptureOptions) error {
    // è¿æ¥åˆ° SCRCPY server
    conn, err := net.Dial("tcp", fmt.Sprintf("%s:%d", c.scrcpyHost, c.scrcpyPort))
    if err != nil {
        return err
    }
    c.conn = conn

    // è¯»å–è®¾å¤‡åç§° (64 bytes)
    deviceName := make([]byte, 64)
    io.ReadFull(conn, deviceName)

    // è¯»å–è§†é¢‘æµ
    go c.readVideoStream(ctx)

    return nil
}

func (c *ScrcpyCapture) readVideoStream(ctx context.Context) {
    for c.running.Load() {
        // SCRCPY åè®®: [4 bytes size][H.264 data]
        sizeBytes := make([]byte, 4)
        io.ReadFull(c.conn, sizeBytes)
        frameSize := binary.BigEndian.Uint32(sizeBytes)

        frameData := make([]byte, frameSize)
        io.ReadFull(c.conn, frameData)

        frame := &Frame{
            Data:      frameData,
            Format:    FrameFormatH264,
            Timestamp: time.Now(),
        }

        select {
        case c.frameChannel <- frame:
        default:
            // ä¸¢å¸§
        }
    }
}
```

---

#### 2A.4 è®¾å¤‡æ± ç®¡ç† API (2 å¤©)

**æ–°å»ºæ–‡ä»¶**:
- `src/physical-devices/physical-devices.controller.ts`
- `src/physical-devices/physical-devices.module.ts`

**API ç«¯ç‚¹**:
```typescript
@Controller('physical-devices')
export class PhysicalDevicesController {
  constructor(private readonly deviceManager: PhysicalDeviceManager) {}

  // æ‰«æè®¾å¤‡
  @Get('scan')
  async scanDevices() {
    const devices = await this.deviceManager.discoverDevices();
    return {
      total: devices.length,
      devices: devices,
    };
  }

  // è®¾å¤‡æ± çŠ¶æ€
  @Get('pool')
  async getDevicePool() {
    const stats = this.deviceManager.getPoolStats();
    const devices = Array.from(this.deviceManager.devices.values());

    return {
      stats: stats,
      devices: devices,
    };
  }

  // WiFi ADB è¿æ¥
  @Post('connect-wifi')
  async connectWifi(@Body() dto: ConnectWifiDto) {
    const serial = await this.deviceManager.connectWifi(dto.ip, dto.port);
    return { serial };
  }

  // æ–­å¼€è®¾å¤‡
  @Delete(':serial')
  async disconnect(@Param('serial') serial: string) {
    await this.deviceManager.disconnect(serial);
    return { message: 'Device disconnected' };
  }
}
```

---

#### 2A.5 å‰ç«¯æ”¯æŒ (2 å¤©)

**è®¾å¤‡æ± ç®¡ç†é¡µé¢**:
- æ˜¾ç¤º 1000+ å°è®¾å¤‡åˆ—è¡¨ (è™šæ‹Ÿæ»šåŠ¨)
- è®¾å¤‡çŠ¶æ€å®æ—¶æ›´æ–° (WebSocket)
- å¥åº·åº¦æ˜¾ç¤º (è¿›åº¦æ¡ + é¢œè‰²)
- WiFi ADB è¿æ¥ç•Œé¢

**åˆ›å»ºè®¾å¤‡é¡µé¢**:
- é€‰æ‹© "ç‰©ç†è®¾å¤‡"
- æ˜¾ç¤ºå¯ç”¨è®¾å¤‡åˆ—è¡¨
- æŒ‰å‹å·/Android ç‰ˆæœ¬ç­›é€‰

---

## ğŸ¢ Phase 2B: ç‰©ç†è®¾å¤‡å¤§è§„æ¨¡ä¼˜åŒ– (Week 5-6)

### ç›®æ ‡

æ”¯æŒ 1000+ å°ç‰©ç†è®¾å¤‡,åˆ†ç‰‡ç®¡ç†,æ™ºèƒ½è°ƒåº¦ã€‚

### æ ¸å¿ƒæŒ‘æˆ˜

| æŒ‘æˆ˜ | è§£å†³æ–¹æ¡ˆ |
|------|---------|
| å•æœåŠ¡å™¨ç®¡ç† 1000+ è®¾å¤‡å‹åŠ›å¤§ | è®¾å¤‡æ± åˆ†ç‰‡ (500å°/åˆ†ç‰‡) |
| è®¾å¤‡å‘ç°æ‰«ææ…¢ | å¹¶å‘æ‰«æ + mDNS å‘ç° |
| å¿ƒè·³æ£€æŸ¥æ€§èƒ½ç“¶é¢ˆ | åˆ†æ‰¹æ£€æŸ¥ + å¢é‡æ›´æ–° |
| è®¾å¤‡åˆ†é…æ•ˆç‡ä½ | æ™ºèƒ½è°ƒåº¦ç®—æ³• + é¢„åˆ†é… |
| è·¨åœ°åŸŸè®¾å¤‡ç®¡ç† | åœ°åŸŸæ„ŸçŸ¥è°ƒåº¦ |

---

### ä»»åŠ¡æ¸…å•

#### 2B.1 è®¾å¤‡æ± åˆ†ç‰‡ç®¡ç† (3 å¤©)

**æ¶æ„è®¾è®¡**:
```typescript
export class ShardedDevicePool {
  private shards: DevicePoolShard[] = [];

  constructor(
    private readonly shardSize: number = 500, // æ¯ä¸ªåˆ†ç‰‡ 500 å°è®¾å¤‡
  ) {
    this.initShards();
  }

  private initShards() {
    const shardCount = Math.ceil(1000 / this.shardSize);
    for (let i = 0; i < shardCount; i++) {
      this.shards.push(new DevicePoolShard(i, this.shardSize));
    }
  }

  async allocateDevice(criteria?: AllocationCriteria): Promise<PhysicalDevice | null> {
    // ç­–ç•¥ 1: è´Ÿè½½å‡è¡¡ (é€‰æ‹©ç©ºé—²è®¾å¤‡æœ€å¤šçš„åˆ†ç‰‡)
    const sortedShards = this.shards
      .sort((a, b) => b.getAvailableCount() - a.getAvailableCount());

    // ç­–ç•¥ 2: å¹¶å‘æŸ¥è¯¢æ‰€æœ‰åˆ†ç‰‡
    const results = await Promise.all(
      sortedShards.map(shard => shard.allocateDevice(criteria))
    );

    return results.find(device => device !== null) || null;
  }

  async healthCheck() {
    // å¹¶å‘æ£€æŸ¥æ‰€æœ‰åˆ†ç‰‡
    await Promise.all(this.shards.map(shard => shard.healthCheck()));
  }

  getShardStats() {
    return this.shards.map(shard => ({
      shardId: shard.id,
      total: shard.devices.size,
      available: shard.getAvailableCount(),
      allocated: shard.getAllocatedCount(),
      offline: shard.getOfflineCount(),
      avgHealthScore: shard.getAvgHealthScore(),
    }));
  }
}

class DevicePoolShard {
  devices = new Map<string, PhysicalDevice>();

  constructor(
    public readonly id: number,
    public readonly maxSize: number,
  ) {}

  async allocateDevice(criteria?: AllocationCriteria): Promise<PhysicalDevice | null> {
    // æœ¬åœ°åˆ†ç‰‡å†…åˆ†é…é€»è¾‘
    // ...
  }

  getAvailableCount(): number {
    return Array.from(this.devices.values())
      .filter(d => d.status === 'available').length;
  }

  // åˆ†æ‰¹å¥åº·æ£€æŸ¥ (æ¯æ‰¹ 50 å°,é¿å…é˜»å¡)
  async healthCheck() {
    const deviceArray = Array.from(this.devices.values());
    const batchSize = 50;

    for (let i = 0; i < deviceArray.length; i += batchSize) {
      const batch = deviceArray.slice(i, i + batchSize);
      await Promise.all(batch.map(device => this.checkDeviceHealth(device)));
    }
  }
}
```

---

#### 2B.2 æ™ºèƒ½è®¾å¤‡è°ƒåº¦å™¨ (3 å¤©)

**è°ƒåº¦ç­–ç•¥**:
```typescript
export class DeviceScheduler {
  // ç­–ç•¥ 1: å¥åº·åº¦ä¼˜å…ˆ
  async scheduleByHealth(criteria: AllocationCriteria): Promise<PhysicalDevice | null> {
    return this.pool.allocateDevice({
      ...criteria,
      sortBy: 'healthScore',
      order: 'desc',
    });
  }

  // ç­–ç•¥ 2: è´Ÿè½½å‡è¡¡
  async scheduleByLoadBalance(criteria: AllocationCriteria): Promise<PhysicalDevice | null> {
    // é€‰æ‹©ä½¿ç”¨ç‡æœ€ä½çš„è®¾å¤‡
    return this.pool.allocateDevice({
      ...criteria,
      sortBy: 'usageRate',
      order: 'asc',
    });
  }

  // ç­–ç•¥ 3: åœ°åŸŸå°±è¿‘
  async scheduleByLocation(userId: string, criteria: AllocationCriteria): Promise<PhysicalDevice | null> {
    const userLocation = await this.getUserLocation(userId);

    return this.pool.allocateDevice({
      ...criteria,
      preferredLocation: userLocation,
    });
  }

  // ç­–ç•¥ 4: äº²å’Œæ€§è°ƒåº¦ (ç”¨æˆ·æŒ‡å®šå‹å·)
  async scheduleByAffinity(criteria: AllocationCriteria): Promise<PhysicalDevice | null> {
    // å¦‚æœç”¨æˆ·æŒ‡å®šäº†å‹å·/Androidç‰ˆæœ¬,ä¼˜å…ˆæ»¡è¶³
    if (criteria.model || criteria.androidVersion) {
      return this.pool.allocateDevice(criteria);
    }

    // å¦åˆ™ä½¿ç”¨é»˜è®¤ç­–ç•¥
    return this.scheduleByHealth(criteria);
  }

  // ç»¼åˆè°ƒåº¦ç­–ç•¥
  async schedule(userId: string, criteria: AllocationCriteria): Promise<PhysicalDevice | null> {
    // 1. äº²å’Œæ€§ä¼˜å…ˆ
    let device = await this.scheduleByAffinity(criteria);
    if (device) return device;

    // 2. åœ°åŸŸå°±è¿‘
    device = await this.scheduleByLocation(userId, criteria);
    if (device) return device;

    // 3. å¥åº·åº¦å…œåº•
    return await this.scheduleByHealth(criteria);
  }
}
```

---

#### 2B.3 åˆ†å¸ƒå¼è®¾å¤‡å‘ç° (2 å¤©)

**å¹¶å‘æ‰«æ + mDNS**:
```typescript
export class DistributedDeviceDiscovery {
  // ç½‘ç»œæ‰«æ (æ”¯æŒå¤šç½‘æ®µå¹¶å‘)
  async scanNetworks(networks: string[]): Promise<PhysicalDevice[]> {
    const results = await Promise.all(
      networks.map(network => this.scanNetwork(network))
    );

    return results.flat();
  }

  private async scanNetwork(networkCidr: string): Promise<PhysicalDevice[]> {
    // å¹¶å‘ ping æ£€æŸ¥
    const ips = this.generateIpRange(networkCidr);
    const batchSize = 50;

    const devices: PhysicalDevice[] = [];

    for (let i = 0; i < ips.length; i += batchSize) {
      const batch = ips.slice(i, i + batchSize);
      const results = await Promise.all(
        batch.map(ip => this.tryConnect(ip, 5555))
      );

      devices.push(...results.filter(d => d !== null));
    }

    return devices;
  }

  // mDNS æœåŠ¡å‘ç° (å¦‚æœè®¾å¤‡æ”¯æŒ)
  async discoverViaMdns(): Promise<PhysicalDevice[]> {
    const mdns = require('mdns');
    const browser = mdns.createBrowser(mdns.tcp('adb'));

    return new Promise((resolve) => {
      const devices: PhysicalDevice[] = [];

      browser.on('serviceUp', (service) => {
        devices.push({
          serial: `${service.addresses[0]}:${service.port}`,
          // ... å…¶ä»–å±æ€§é€šè¿‡ ADB æŸ¥è¯¢
        });
      });

      browser.start();

      setTimeout(() => {
        browser.stop();
        resolve(devices);
      }, 10000); // 10ç§’æ‰«æ
    });
  }
}
```

---

#### 2B.4 è®¾å¤‡å¥åº·è¯„åˆ†ç³»ç»Ÿ (2 å¤©)

**è¯„åˆ†ç®—æ³•**:
```typescript
export class DeviceHealthScorer {
  calculateScore(device: PhysicalDevice): number {
    let score = 100;

    // 1. å¿ƒè·³å»¶è¿Ÿ (-0-20åˆ†)
    const heartbeatDelay = Date.now() - device.lastHeartbeatAt.getTime();
    if (heartbeatDelay > 60000) score -= 20; // è¶…è¿‡ 1 åˆ†é’Ÿ
    else if (heartbeatDelay > 30000) score -= 10;

    // 2. è¿æ¥ç¨³å®šæ€§ (-0-20åˆ†)
    const disconnectRate = device.disconnectCount / device.totalConnections;
    score -= disconnectRate * 20;

    // 3. ADB å“åº”æ—¶é—´ (-0-15åˆ†)
    if (device.avgAdbResponseTime > 1000) score -= 15; // è¶…è¿‡ 1 ç§’
    else if (device.avgAdbResponseTime > 500) score -= 10;

    // 4. è®¾å¤‡æ¸©åº¦ (-0-15åˆ†,ç‰©ç†è®¾å¤‡ç‰¹æœ‰)
    if (device.temperature > 45) score -= 15; // è¶…è¿‡ 45Â°C
    else if (device.temperature > 40) score -= 10;

    // 5. ç”µæ± ç”µé‡ (-0-10åˆ†,ç‰©ç†è®¾å¤‡ç‰¹æœ‰)
    if (device.batteryLevel < 20) score -= 10;
    else if (device.batteryLevel < 50) score -= 5;

    // 6. å­˜å‚¨ç©ºé—´ (-0-10åˆ†)
    if (device.freeStorageMB < 1000) score -= 10; // å°‘äº 1GB
    else if (device.freeStorageMB < 5000) score -= 5;

    // 7. å†å²æ•…éšœç‡ (-0-10åˆ†)
    if (device.errorRate > 0.1) score -= 10; // è¶…è¿‡ 10%
    else if (device.errorRate > 0.05) score -= 5;

    return Math.max(0, Math.min(100, score));
  }

  // è‡ªåŠ¨å‰”é™¤ä¸å¥åº·è®¾å¤‡
  @Cron('0 */5 * * * *') // æ¯ 5 åˆ†é’Ÿ
  async autoRemoveUnhealthyDevices() {
    const devices = await this.pool.getAllDevices();

    for (const device of devices) {
      const score = this.calculateScore(device);

      if (score < 30) {
        // å¥åº·åº¦ < 30,è‡ªåŠ¨å‰”é™¤
        await this.pool.removeDevice(device.serial);
        this.logger.warn(`Device ${device.serial} removed due to low health score: ${score}`);

        // å‘é€å‘Šè­¦
        await this.alertService.sendAlert({
          level: 'warning',
          message: `Physical device ${device.serial} (${device.model}) removed from pool due to health issues`,
        });
      }
    }
  }
}
```

---

#### 2B.5 ç›‘æ§å’Œå‘Šè­¦ (2 å¤©)

**Prometheus æŒ‡æ ‡**:
```typescript
// è®¾å¤‡æ± æŒ‡æ ‡
this.devicePoolTotal.set({ shard: shardId }, total);
this.devicePoolAvailable.set({ shard: shardId }, available);
this.devicePoolAllocated.set({ shard: shardId }, allocated);
this.devicePoolOffline.set({ shard: shardId }, offline);
this.devicePoolAvgHealth.set({ shard: shardId }, avgHealth);

// è°ƒåº¦æŒ‡æ ‡
this.deviceAllocationDuration.observe({ strategy: 'health' }, duration);
this.deviceAllocationFailures.inc({ reason: 'no_device' });

// è®¾å¤‡å¥åº·æŒ‡æ ‡
this.deviceHealthScore.set({ serial: device.serial }, device.healthScore);
this.deviceHeartbeatDelay.set({ serial: device.serial }, delay);
```

**å‘Šè­¦è§„åˆ™**:
```yaml
groups:
  - name: physical_devices
    rules:
      # å¯ç”¨è®¾å¤‡ä¸è¶³
      - alert: PhysicalDevicePoolLow
        expr: sum(device_pool_available) / sum(device_pool_total) < 0.2
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "ç‰©ç†è®¾å¤‡æ± å¯ç”¨è®¾å¤‡ä¸è¶³ 20%"

      # ç¦»çº¿è®¾å¤‡è¿‡å¤š
      - alert: PhysicalDeviceOfflineHigh
        expr: sum(device_pool_offline) / sum(device_pool_total) > 0.1
        for: 10m
        labels:
          severity: critical
        annotations:
          summary: "è¶…è¿‡ 10% ç‰©ç†è®¾å¤‡ç¦»çº¿"

      # è®¾å¤‡åˆ†é…å¤±è´¥ç‡é«˜
      - alert: DeviceAllocationFailureHigh
        expr: rate(device_allocation_failures_total[5m]) > 0.1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "è®¾å¤‡åˆ†é…å¤±è´¥ç‡è¶…è¿‡ 10%"
```

---

#### 2B.6 æ€§èƒ½æµ‹è¯• (2 å¤©)

**æµ‹è¯•åœºæ™¯**:
1. 1000 å°è®¾å¤‡å¹¶å‘å¥åº·æ£€æŸ¥ (ç›®æ ‡: <30ç§’)
2. é«˜å¹¶å‘è®¾å¤‡åˆ†é… (100 QPS,æˆåŠŸç‡ >95%)
3. è®¾å¤‡æ± åˆ†ç‰‡è´Ÿè½½å‡è¡¡
4. è®¾å¤‡æ•…éšœè‡ªåŠ¨å‰”é™¤å’Œæ¢å¤

---

## â˜ï¸ Phase 3: åä¸ºäº‘æ‰‹æœº CPH (Week 7-8)

### ç›®æ ‡

å¯¹æ¥åä¸ºäº‘æ‰‹æœº CPH API,æ”¯æŒäº‘ç«¯ Android å®ä¾‹ã€‚

### ä»»åŠ¡æ¸…å•

#### 3.1 åä¸º CPH SDK å®¢æˆ·ç«¯ (4 å¤©)

**æ–°å»ºæ–‡ä»¶**:
- `src/providers/huawei/huawei-cph.client.ts`
- `src/providers/huawei/huawei.provider.ts`
- `src/providers/huawei/huawei.module.ts`

**IAM è®¤è¯**:
```typescript
@Injectable()
export class HuaweiCphClient {
  private readonly apiEndpoint: string;
  private readonly iamEndpoint: string;
  private readonly projectId: string;
  private readonly username: string;
  private readonly password: string;

  private tokenCache: { token: string; expiresAt: Date } | null = null;

  constructor(private readonly configService: ConfigService) {
    this.apiEndpoint = configService.get('HUAWEI_API_ENDPOINT');
    this.iamEndpoint = configService.get('HUAWEI_IAM_ENDPOINT');
    this.projectId = configService.get('HUAWEI_PROJECT_ID');
    this.username = configService.get('HUAWEI_USERNAME');
    this.password = configService.get('HUAWEI_PASSWORD');
  }

  // è·å– IAM Token
  private async getToken(): Promise<string> {
    if (this.tokenCache && this.tokenCache.expiresAt > new Date()) {
      return this.tokenCache.token;
    }

    const response = await this.httpClient.post(`${this.iamEndpoint}/v3/auth/tokens`, {
      auth: {
        identity: {
          methods: ['password'],
          password: {
            user: {
              name: this.username,
              password: this.password,
              domain: { name: this.username },
            },
          },
        },
        scope: {
          project: { id: this.projectId },
        },
      },
    });

    const token = response.headers['x-subject-token'];
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24å°æ—¶

    this.tokenCache = { token, expiresAt };

    return token;
  }

  // åˆ›å»ºäº‘æ‰‹æœºå®ä¾‹
  async createInstance(options: HuaweiInstanceOptions): Promise<HuaweiInstance> {
    const token = await this.getToken();

    const response = await this.httpClient.post(
      `${this.apiEndpoint}/v1/${this.projectId}/cloud-phone/phones`,
      {
        server_id: options.serverId,       // äº‘æ‰‹æœºæœåŠ¡å™¨ ID
        phone_name: options.name,
        phone_model_name: options.modelName, // è§„æ ¼å‹å·
        image_id: options.imageId,         // é•œåƒ ID
        // ... å…¶ä»–å‚æ•°
      },
      {
        headers: {
          'X-Auth-Token': token,
        },
      }
    );

    return response.data;
  }

  // è·å–æŠ•å±åœ°å€
  async getConnectionInfo(phoneId: string): Promise<HuaweiConnectionInfo> {
    const token = await this.getToken();

    const response = await this.httpClient.post(
      `${this.apiEndpoint}/v1/${this.projectId}/cloud-phone/phones/batch-connection`,
      {
        phone_ids: [phoneId],
      },
      {
        headers: {
          'X-Auth-Token': token,
        },
      }
    );

    const phone = response.data.phones[0];

    return {
      instanceId: phone.phone_id,
      accessIp: phone.access_info.access_ip,
      accessPort: phone.access_info.access_port,
      sessionId: phone.access_info.session_id,
      ticket: phone.access_info.ticket,
    };
  }

  // æ‰§è¡Œ ADB å‘½ä»¤ (åŒæ­¥)
  async executeAdbCommand(phoneId: string, command: string): Promise<string> {
    const token = await this.getToken();

    const response = await this.httpClient.post(
      `${this.apiEndpoint}/v1/${this.projectId}/cloud-phone/phones/commands`,
      {
        phone_ids: [phoneId],
        command: 'adb_shell',
        content: command,
      },
      {
        headers: {
          'X-Auth-Token': token,
        },
      }
    );

    return response.data.jobs[0].result;
  }

  // å®‰è£… APK
  async installApk(phoneId: string, apkUrl: string): Promise<string> {
    const token = await this.getToken();

    const response = await this.httpClient.post(
      `${this.apiEndpoint}/v1/${this.projectId}/cloud-phone/phones/commands`,
      {
        phone_ids: [phoneId],
        command: 'install',
        content: apkUrl, // OBS å­˜å‚¨è·¯å¾„
      },
      {
        headers: {
          'X-Auth-Token': token,
        },
      }
    );

    return response.data.jobs[0].job_id;
  }

  // é”€æ¯å®ä¾‹
  async destroyInstance(phoneId: string): Promise<void> {
    const token = await this.getToken();

    await this.httpClient.post(
      `${this.apiEndpoint}/v1/${this.projectId}/cloud-phone/phones/batch-delete`,
      {
        phone_ids: [phoneId],
      },
      {
        headers: {
          'X-Auth-Token': token,
        },
      }
    );
  }
}
```

---

#### 3.2 åä¸º Provider å®ç° (3 å¤©)

```typescript
@Injectable()
export class HuaweiProvider implements IDeviceProvider {
  readonly providerType = DeviceProviderType.HUAWEI_CPH;

  constructor(
    private readonly client: HuaweiCphClient,
    private readonly logger: Logger,
  ) {}

  async create(config: DeviceCreateConfig): Promise<ProviderDevice> {
    // 1. åˆ›å»ºäº‘æ‰‹æœºå®ä¾‹ (å¼‚æ­¥)
    const instance = await this.client.createInstance({
      name: config.name,
      serverId: config.providerSpecificConfig?.serverId,
      modelName: this.selectModelName(config.cpuCores, config.memoryMB),
      imageId: this.selectImageId(config.androidVersion),
    });

    // 2. ç­‰å¾…å®ä¾‹å°±ç»ª (è½®è¯¢çŠ¶æ€)
    await this.waitForInstanceReady(instance.phone_id);

    // 3. è·å–è¿æ¥ä¿¡æ¯
    const connectionInfo = await this.client.getConnectionInfo(instance.phone_id);

    return {
      deviceId: instance.phone_id,
      providerConfig: {
        phoneId: instance.phone_id,
        serverId: instance.server_id,
        modelName: instance.phone_model_name,
      },
      connectionInfo: {
        providerType: DeviceProviderType.HUAWEI_CPH,
        huaweiCph: connectionInfo,
      },
    };
  }

  private async waitForInstanceReady(phoneId: string, timeout: number = 300000): Promise<void> {
    const startTime = Date.now();

    while (Date.now() - startTime < timeout) {
      const status = await this.client.getInstanceStatus(phoneId);

      if (status === 'Running') {
        return;
      } else if (status === 'Error') {
        throw new Error(`Instance ${phoneId} creation failed`);
      }

      await this.sleep(5000); // 5ç§’è½®è¯¢
    }

    throw new Error(`Instance ${phoneId} creation timeout`);
  }

  async getConnectionInfo(deviceId: string): Promise<ConnectionInfo> {
    const connectionInfo = await this.client.getConnectionInfo(deviceId);

    return {
      providerType: DeviceProviderType.HUAWEI_CPH,
      huaweiCph: connectionInfo,
    };
  }

  getCapabilities(): DeviceCapabilities {
    return {
      supportsAdb: true,
      supportsScreenCapture: true,
      supportsAudioCapture: true,
      supportedCaptureFormats: [
        CaptureFormat.SCREENRECORD, // é€šè¿‡ ADB
      ],
      maxResolution: { width: 1920, height: 1080 },
      supportsTouchControl: true,
      supportsKeyboardInput: true,
      supportsFileTransfer: true,
      supportsAppInstall: true,
      supportsSensorSimulation: true,
      supportsCamera: false,
      supportsMicrophone: false,
      supportsBatterySimulation: false,
    };
  }

  // å…¶ä»–æ–¹æ³•å®ç°...
}
```

---

#### 3.3 Media Service é€‚é… (3 å¤©)

**Huawei Stream Capture** (Go):
```go
// backend/media-service/internal/capture/huawei_stream_capture.go

type HuaweiStreamCapture struct {
    instanceId   string
    accessIp     string
    accessPort   int
    sessionId    string
    ticket       string
    frameChannel chan *Frame
    adbSerial    string  // å¦‚æœæ”¯æŒ ADB
    logger       *logrus.Logger
}

func (c *HuaweiStreamCapture) Start(ctx context.Context, options CaptureOptions) error {
    // æ–¹æ¡ˆ 1: å¦‚æœåä¸ºæä¾›æŠ•å± API,é€šè¿‡ HTTP/WebSocket æ‹‰æµ
    if c.hasStreamApi() {
        return c.startStreamApi(ctx)
    }

    // æ–¹æ¡ˆ 2: é€šè¿‡ ADB screenrecord (é™çº§)
    if c.adbSerial != "" {
        return c.startAdbScreenrecord(ctx)
    }

    return fmt.Errorf("no available capture method")
}

func (c *HuaweiStreamCapture) startAdbScreenrecord(ctx context.Context) error {
    // å¤ç”¨ç°æœ‰ ADB screenrecord é€»è¾‘
    cmd := exec.CommandContext(ctx, "adb", "-s", c.adbSerial,
        "shell", "screenrecord", "--output-format=h264", "-")

    stdout, _ := cmd.StdoutPipe()
    cmd.Start()

    go c.readH264Stream(stdout)

    return nil
}
```

---

#### 3.4 å‰ç«¯å’Œæµ‹è¯• (2 å¤©)

**å‰ç«¯**:
- åˆ›å»ºè®¾å¤‡é¡µé¢æ·»åŠ  "åä¸ºäº‘æ‰‹æœº" é€‰é¡¹
- é…ç½®æœåŠ¡å™¨ IDã€è§„æ ¼é€‰æ‹©
- æ˜¾ç¤ºå®ä¾‹åˆ›å»ºè¿›åº¦

**æµ‹è¯•**:
- åä¸ºæµ‹è¯•è´¦å·éªŒè¯
- å®ä¾‹åˆ›å»º â†’ æŠ•å± â†’ é”€æ¯å®Œæ•´æµç¨‹
- æˆæœ¬ç›‘æ§ (æŒ‰å°æ—¶è®¡è´¹)

---

## â˜ï¸ Phase 4: é˜¿é‡Œäº‘æ‰‹æœº ECP (Week 9-10)

### ç›®æ ‡

å¯¹æ¥é˜¿é‡Œäº‘ ECP API,æ”¯æŒ WebRTC æŠ•å±ã€‚

### ä»»åŠ¡æ¸…å•

#### 4.1 é˜¿é‡Œäº‘ ECP SDK å®¢æˆ·ç«¯ (4 å¤©)

**AK/SK ç­¾åè®¤è¯**:
```typescript
@Injectable()
export class AliyunEcpClient {
  private readonly endpoint: string;
  private readonly accessKeyId: string;
  private readonly accessKeySecret: string;

  constructor(private readonly configService: ConfigService) {
    this.endpoint = configService.get('ALIYUN_ECP_ENDPOINT');
    this.accessKeyId = configService.get('ALIYUN_ACCESS_KEY_ID');
    this.accessKeySecret = configService.get('ALIYUN_ACCESS_KEY_SECRET');
  }

  // AK/SK ç­¾å
  private sign(params: Record<string, any>): string {
    const sortedKeys = Object.keys(params).sort();
    const canonicalString = sortedKeys
      .map(key => `${key}=${encodeURIComponent(params[key])}`)
      .join('&');

    const stringToSign = `GET&${encodeURIComponent('/')}&${encodeURIComponent(canonicalString)}`;

    return crypto
      .createHmac('sha1', this.accessKeySecret + '&')
      .update(stringToSign)
      .digest('base64');
  }

  // åˆ›å»ºå®ä¾‹
  async runInstances(options: AliyunInstanceOptions): Promise<AliyunInstance> {
    const params = {
      Action: 'RunInstances',
      InstanceType: options.instanceType,
      InstanceName: options.name,
      ImageId: options.imageId,
      Amount: 1,
      AccessKeyId: this.accessKeyId,
      Timestamp: new Date().toISOString(),
      SignatureMethod: 'HMAC-SHA1',
      SignatureVersion: '1.0',
      SignatureNonce: Math.random().toString(36),
      Format: 'JSON',
    };

    params['Signature'] = this.sign(params);

    const response = await this.httpClient.get(this.endpoint, { params });

    return response.data.Instances.Instance[0];
  }

  // è·å– WebRTC Token
  async getWebRtcToken(instanceId: string): Promise<string> {
    const params = {
      Action: 'GetWebRtcToken',
      InstanceId: instanceId,
      // ... å…¶ä»–å‚æ•°
    };

    params['Signature'] = this.sign(params);

    const response = await this.httpClient.get(this.endpoint, { params });

    return response.data.WebRtcToken;
  }

  // é”€æ¯å®ä¾‹
  async deleteInstances(instanceId: string): Promise<void> {
    const params = {
      Action: 'DeleteInstances',
      InstanceId: [instanceId],
      // ...
    };

    params['Signature'] = this.sign(params);

    await this.httpClient.get(this.endpoint, { params });
  }
}
```

---

#### 4.2 é˜¿é‡Œäº‘ Provider å®ç° (3 å¤©)

```typescript
@Injectable()
export class AliyunProvider implements IDeviceProvider {
  readonly providerType = DeviceProviderType.ALIYUN_ECP;

  constructor(
    private readonly client: AliyunEcpClient,
    private readonly logger: Logger,
  ) {}

  async create(config: DeviceCreateConfig): Promise<ProviderDevice> {
    // 1. åˆ›å»ºå®ä¾‹
    const instance = await this.client.runInstances({
      name: config.name,
      instanceType: this.selectInstanceType(config.cpuCores, config.memoryMB),
      imageId: this.selectImageId(config.androidVersion),
    });

    // 2. ç­‰å¾…å®ä¾‹å°±ç»ª
    await this.waitForInstanceReady(instance.InstanceId);

    // 3. è·å– WebRTC Token
    const webrtcToken = await this.client.getWebRtcToken(instance.InstanceId);

    return {
      deviceId: instance.InstanceId,
      providerConfig: {
        instanceId: instance.InstanceId,
        instanceType: instance.InstanceType,
      },
      connectionInfo: {
        providerType: DeviceProviderType.ALIYUN_ECP,
        aliyunEcp: {
          instanceId: instance.InstanceId,
          webrtcToken: webrtcToken,
          webrtcUrl: `wss://ecp.aliyuncs.com/webrtc/${instance.InstanceId}`,
          tokenExpiresAt: new Date(Date.now() + 30000), // 30ç§’
        },
      },
    };
  }

  async getConnectionInfo(deviceId: string): Promise<ConnectionInfo> {
    // Token åˆ·æ–°é€»è¾‘
    const webrtcToken = await this.client.getWebRtcToken(deviceId);

    return {
      providerType: DeviceProviderType.ALIYUN_ECP,
      aliyunEcp: {
        instanceId: deviceId,
        webrtcToken: webrtcToken,
        webrtcUrl: `wss://ecp.aliyuncs.com/webrtc/${deviceId}`,
        tokenExpiresAt: new Date(Date.now() + 30000),
      },
    };
  }

  getCapabilities(): DeviceCapabilities {
    return {
      supportsAdb: true, // é€šè¿‡å¯†é’¥å¯¹
      supportsScreenCapture: true,
      supportsAudioCapture: true,
      supportedCaptureFormats: [
        CaptureFormat.WEBRTC, // ä¸»æ¨
        CaptureFormat.SCREENRECORD,
      ],
      maxResolution: { width: 1920, height: 1080 },
      supportsTouchControl: true,
      supportsKeyboardInput: true,
      supportsFileTransfer: true,
      supportsAppInstall: true,
      supportsSensorSimulation: true,
      supportsCamera: false,
      supportsMicrophone: false,
      supportsBatterySimulation: false,
    };
  }
}
```

---

#### 4.3 Media Service WebRTC Passthrough (4 å¤©)

**Aliyun WebRTC Capture** (Go):
```go
// backend/media-service/internal/capture/aliyun_webrtc_capture.go

type AliyunWebRtcCapture struct {
    instanceId   string
    webrtcUrl    string
    webrtcToken  string
    tokenExpires time.Time
    peerConn     *webrtc.PeerConnection
    videoTrack   *webrtc.TrackRemote
    frameChannel chan *Frame
    logger       *logrus.Logger
}

func (c *AliyunWebRtcCapture) Start(ctx context.Context, options CaptureOptions) error {
    // 1. åˆ›å»º PeerConnection
    config := webrtc.Configuration{
        ICEServers: []webrtc.ICEServer{
            {URLs: []string{"stun:stun.l.google.com:19302"}},
        },
    }

    pc, err := webrtc.NewPeerConnection(config)
    if err != nil {
        return err
    }
    c.peerConn = pc

    // 2. ç›‘å¬ Track (æ¥æ”¶é˜¿é‡Œäº‘çš„è§†é¢‘æµ)
    pc.OnTrack(func(track *webrtc.TrackRemote, receiver *webrtc.RTPReceiver) {
        if track.Kind() == webrtc.RTPCodecTypeVideo {
            c.videoTrack = track
            go c.readVideoTrack(track)
        }
    })

    // 3. è¿æ¥åˆ°é˜¿é‡Œäº‘ WebRTC æœåŠ¡å™¨
    err = c.connectToAliyun()
    if err != nil {
        return err
    }

    // 4. Token åˆ·æ–°å®šæ—¶å™¨
    go c.startTokenRefresh(ctx)

    return nil
}

func (c *AliyunWebRtcCapture) readVideoTrack(track *webrtc.TrackRemote) {
    for {
        // è¯»å– RTP åŒ…
        rtp, _, err := track.ReadRTP()
        if err != nil {
            return
        }

        // è§£æ H.264 NAL units
        frame := &Frame{
            Data:      rtp.Payload,
            Format:    FrameFormatH264,
            Timestamp: time.Now(),
        }

        select {
        case c.frameChannel <- frame:
        default:
            // ä¸¢å¸§
        }
    }
}

func (c *AliyunWebRtcCapture) startTokenRefresh(ctx context.Context) {
    ticker := time.NewTicker(25 * time.Second) // Token 30ç§’æœ‰æ•ˆ,æå‰ 5ç§’åˆ·æ–°
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            // é‡æ–°è·å– Token å¹¶é‡è¿
            newToken, err := c.refreshToken()
            if err != nil {
                c.logger.WithError(err).Error("Failed to refresh WebRTC token")
                continue
            }

            c.webrtcToken = newToken
            c.tokenExpires = time.Now().Add(30 * time.Second)

            // é‡å»º PeerConnection
            c.reconnect()
        }
    }
}
```

---

#### 4.4 å‰ç«¯å’Œæµ‹è¯• (1 å¤©)

**å‰ç«¯**:
- åˆ›å»ºè®¾å¤‡é¡µé¢æ·»åŠ  "é˜¿é‡Œäº‘æ‰‹æœº" é€‰é¡¹
- æ˜¾ç¤ºå®ä¾‹åˆ›å»ºè¿›åº¦
- WebRTC æŠ•å±é›†æˆ

**æµ‹è¯•**:
- é˜¿é‡Œäº‘æµ‹è¯•è´¦å·éªŒè¯
- WebRTC Token åˆ·æ–°æœºåˆ¶
- æ–­ç½‘é‡è¿æµ‹è¯•

---

## ğŸ“Š Phase 5: ç›‘æ§ä¼˜åŒ– (Week 11)

### ç›®æ ‡

å®Œå–„ç›‘æ§å‘Šè­¦,æ€§èƒ½ä¼˜åŒ–,ä¸Šçº¿å‡†å¤‡ã€‚

### ä»»åŠ¡æ¸…å•

#### 5.1 ç»Ÿä¸€ç›‘æ§å¤§ç›˜ (2 å¤©)

**Grafana Dashboard**:
- è®¾å¤‡æ± æ€»è§ˆ (æŒ‰æä¾›å•†åˆ†ç»„)
- ç‰©ç†è®¾å¤‡å¥åº·åº¦çƒ­åŠ›å›¾ (1000+ å°å¯è§†åŒ–)
- è®¾å¤‡åˆ†é…æˆåŠŸç‡/å»¶è¿Ÿ
- æˆæœ¬ç›‘æ§ (äº‘æ‰‹æœºæŒ‰å°æ—¶)
- æŠ•å±æ€§èƒ½ (FPS, å»¶è¿Ÿ)

---

#### 5.2 å‘Šè­¦è§„åˆ™å®Œå–„ (1 å¤©)

**Prometheus Alerts**:
```yaml
groups:
  - name: multi_provider
    rules:
      # ç‰©ç†è®¾å¤‡æ± å‘Šè­¦ (å·²æœ‰)

      # åä¸ºäº‘æ‰‹æœºå‘Šè­¦
      - alert: HuaweiInstanceCreationSlow
        expr: histogram_quantile(0.95, provider_operation_duration_seconds{provider_type="huawei_cph",operation="create"}) > 300
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "åä¸ºäº‘æ‰‹æœºå®ä¾‹åˆ›å»ºè¿‡æ…¢ (P95 > 5åˆ†é’Ÿ)"

      # é˜¿é‡Œäº‘æ‰‹æœºå‘Šè­¦
      - alert: AliyunWebRtcTokenRefreshFailure
        expr: rate(aliyun_webrtc_token_refresh_failures_total[5m]) > 0.1
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "é˜¿é‡Œäº‘ WebRTC Token åˆ·æ–°å¤±è´¥ç‡ > 10%"

      # è·¨æä¾›å•†å‘Šè­¦
      - alert: DeviceProviderDown
        expr: up{job="device-service"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Device Service ä¸å¯ç”¨,å½±å“æ‰€æœ‰æä¾›å•†"
```

---

#### 5.3 æ€§èƒ½ä¼˜åŒ– (2 å¤©)

**ä¼˜åŒ–é¡¹**:
1. æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ– (ç´¢å¼•,è¿æ¥æ± )
2. Redis ç¼“å­˜ ConnectionInfo (å‡å°‘ API è°ƒç”¨)
3. è®¾å¤‡æ± æŸ¥è¯¢ä¼˜åŒ– (åˆ†ç‰‡å¹¶å‘)
4. å‰ç«¯è™šæ‹Ÿæ»šåŠ¨ (1000+ è®¾å¤‡åˆ—è¡¨)

---

#### 5.4 æ–‡æ¡£å®Œå–„ (1 å¤©)

**äº¤ä»˜æ–‡æ¡£**:
- éƒ¨ç½²æŒ‡å— (Docker Compose / Kubernetes)
- è¿ç»´æ‰‹å†Œ (æ•…éšœæ’æŸ¥,æ‰©å®¹æŒ‡å—)
- API æ–‡æ¡£ (Swagger)
- å¼€å‘è€…æŒ‡å— (å¦‚ä½•æ·»åŠ æ–°æä¾›å•†)

---

## ğŸ“¦ äº¤ä»˜æ¸…å•

### ä»£ç äº¤ä»˜

#### Device Service

```
backend/device-service/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ providers/
â”‚   â”‚   â”œâ”€â”€ provider.types.ts                  âœ… å·²å®Œæˆ
â”‚   â”‚   â”œâ”€â”€ device-provider.interface.ts       âœ… å·²å®Œæˆ
â”‚   â”‚   â”œâ”€â”€ device-provider.factory.ts         â³ Phase 1
â”‚   â”‚   â”œâ”€â”€ providers.module.ts                â³ Phase 1
â”‚   â”‚   â”œâ”€â”€ redroid/
â”‚   â”‚   â”‚   â”œâ”€â”€ redroid.provider.ts            â³ Phase 1
â”‚   â”‚   â”‚   â””â”€â”€ redroid.module.ts              â³ Phase 1
â”‚   â”‚   â”œâ”€â”€ physical/
â”‚   â”‚   â”‚   â”œâ”€â”€ physical-device.manager.ts     â³ Phase 2A
â”‚   â”‚   â”‚   â”œâ”€â”€ physical.provider.ts           â³ Phase 2A
â”‚   â”‚   â”‚   â”œâ”€â”€ scrcpy.service.ts              â³ Phase 2A
â”‚   â”‚   â”‚   â”œâ”€â”€ sharded-pool.ts                â³ Phase 2B
â”‚   â”‚   â”‚   â”œâ”€â”€ device-scheduler.ts            â³ Phase 2B
â”‚   â”‚   â”‚   â”œâ”€â”€ device-discovery.ts            â³ Phase 2B
â”‚   â”‚   â”‚   â”œâ”€â”€ health-scorer.ts               â³ Phase 2B
â”‚   â”‚   â”‚   â””â”€â”€ physical.module.ts             â³ Phase 2A
â”‚   â”‚   â”œâ”€â”€ huawei/
â”‚   â”‚   â”‚   â”œâ”€â”€ huawei-cph.client.ts           â³ Phase 3
â”‚   â”‚   â”‚   â”œâ”€â”€ huawei.provider.ts             â³ Phase 3
â”‚   â”‚   â”‚   â””â”€â”€ huawei.module.ts               â³ Phase 3
â”‚   â”‚   â””â”€â”€ aliyun/
â”‚   â”‚       â”œâ”€â”€ aliyun-ecp.client.ts           â³ Phase 4
â”‚   â”‚       â”œâ”€â”€ aliyun.provider.ts             â³ Phase 4
â”‚   â”‚       â””â”€â”€ aliyun.module.ts               â³ Phase 4
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â””â”€â”€ device.entity.ts                   â³ Phase 1 (ä¿®æ”¹)
â”‚   â”œâ”€â”€ devices/
â”‚   â”‚   â”œâ”€â”€ devices.service.ts                 â³ Phase 1 (ä¿®æ”¹)
â”‚   â”‚   â”œâ”€â”€ devices.controller.ts              â³ Phase 1 (ä¿®æ”¹)
â”‚   â”‚   â””â”€â”€ dto/create-device.dto.ts           â³ Phase 1 (ä¿®æ”¹)
â”‚   â””â”€â”€ physical-devices/
â”‚       â”œâ”€â”€ physical-devices.controller.ts     â³ Phase 2A
â”‚       â””â”€â”€ physical-devices.module.ts         â³ Phase 2A
â””â”€â”€ migrations/
    â””â”€â”€ xxx_add_provider_fields.sql            â³ Phase 1
```

#### Media Service

```
backend/media-service/internal/capture/
â”œâ”€â”€ scrcpy_capture.go                          â³ Phase 2A
â”œâ”€â”€ huawei_stream_capture.go                   â³ Phase 3
â””â”€â”€ aliyun_webrtc_capture.go                   â³ Phase 4
```

#### Frontend

```
frontend/admin/src/
â”œâ”€â”€ pages/Device/
â”‚   â”œâ”€â”€ CreateDevice.tsx                       â³ Phase 1 (ä¿®æ”¹)
â”‚   â”œâ”€â”€ DeviceList.tsx                         â³ Phase 1 (ä¿®æ”¹)
â”‚   â””â”€â”€ PhysicalDevicePool.tsx                 â³ Phase 2A (æ–°å¢)
â””â”€â”€ components/
    â””â”€â”€ ProviderBadge.tsx                      â³ Phase 1 (æ–°å¢)
```

---

### æ–‡æ¡£äº¤ä»˜

- âœ… `MULTI_DEVICE_PROVIDER_FINAL_PLAN.md` (æœ¬æ–‡æ¡£)
- â³ `DEPLOYMENT_GUIDE.md` - éƒ¨ç½²æŒ‡å—
- â³ `OPERATION_MANUAL.md` - è¿ç»´æ‰‹å†Œ
- â³ `DEVELOPER_GUIDE.md` - å¼€å‘è€…æŒ‡å—
- â³ `API_REFERENCE.md` - API æ–‡æ¡£

---

### æµ‹è¯•äº¤ä»˜

- â³ å•å…ƒæµ‹è¯• (è¦†ç›–ç‡ >70%)
- â³ é›†æˆæµ‹è¯• (E2E)
- â³ æ€§èƒ½æµ‹è¯•æŠ¥å‘Š (1000+ å°è®¾å¤‡)
- â³ æ•…éšœæ¢å¤æµ‹è¯•

---

## ğŸ’° æˆæœ¬ä¼°ç®—

### å¼€å‘æˆæœ¬

| é˜¶æ®µ | å·¥ä½œé‡ | å¼€å‘äººå‘˜ | æ—¶é—´ |
|------|--------|---------|------|
| Phase 1: åŸºç¡€æ¶æ„ | 14 å¤© | 2 äºº | 2 å‘¨ |
| Phase 2A: ç‰©ç†è®¾å¤‡åŸºç¡€ | 15 å¤© | 2 äºº | 2 å‘¨ |
| Phase 2B: ç‰©ç†è®¾å¤‡å¤§è§„æ¨¡ | 12 å¤© | 2 äºº | 2 å‘¨ |
| Phase 3: åä¸ºäº‘æ‰‹æœº | 12 å¤© | 2 äºº | 2 å‘¨ |
| Phase 4: é˜¿é‡Œäº‘æ‰‹æœº | 12 å¤© | 2 äºº | 2 å‘¨ |
| Phase 5: ç›‘æ§ä¼˜åŒ– | 6 å¤© | 2 äºº | 1 å‘¨ |
| **æ€»è®¡** | **71 å¤©** | **2-3 äºº** | **11 å‘¨** |

### è¿è¥æˆæœ¬ (æœˆåº¦,1100 å°è®¾å¤‡)

| è®¾å¤‡æº | æ•°é‡ | å•ä»· | æœˆæˆæœ¬ | å¤‡æ³¨ |
|-------|------|------|--------|------|
| **ç‰©ç†è®¾å¤‡** | 1000 å° | Â¥150/æœˆ | Â¥150,000 | ä¸€æ¬¡æ€§æŠ•å…¥ Â¥3,000,000 |
| **Redroid** | 50 å° | Â¥200/æœˆ | Â¥10,000 | è‡ªæœ‰æœåŠ¡å™¨ |
| **åä¸º CPH** | 25 å° | Â¥1.5/å°æ—¶ Ã— 720h | Â¥27,000 | æŒ‰éœ€ä½¿ç”¨ |
| **é˜¿é‡Œäº‘ ECP** | 25 å° | Â¥1.2/å°æ—¶ Ã— 720h | Â¥21,600 | æŒ‰éœ€ä½¿ç”¨ |
| **æ€»æˆæœ¬** | 1100 å° | - | **Â¥208,600** | å¹³å‡ Â¥189.6/å°/æœˆ |

**æˆæœ¬ä¼˜åŒ–å»ºè®®**:
- ç‰©ç†è®¾å¤‡å ä¸»åŠ› (æˆæœ¬æœ€ä½)
- äº‘æ‰‹æœºç”¨äºå¼¹æ€§æ‰©å±•å’Œè·¨åœ°åŸŸ
- Redroid ç”¨äºå¼€å‘æµ‹è¯•

---

## ğŸ¯ å…³é”®æˆåŠŸå› ç´ 

### æŠ€æœ¯é£é™©

| é£é™© | ç¼“è§£æªæ–½ |
|------|---------|
| 1000+ å°è®¾å¤‡æ€§èƒ½ç“¶é¢ˆ | åˆ†ç‰‡ç®¡ç†,å¹¶å‘ä¼˜åŒ–,å‹æµ‹éªŒè¯ |
| ç‰©ç†è®¾å¤‡ç½‘ç»œä¸ç¨³å®š | å¥åº·ç›‘æ§,è‡ªåŠ¨å‰”é™¤,æ•…éšœæ¢å¤ |
| äº‘æ‰‹æœº API é™æµ | è¯·æ±‚é™æµ,å¤±è´¥é‡è¯•,é™çº§ç­–ç•¥ |
| WebRTC Token è¿‡æœŸ | æå‰åˆ·æ–°,è‡ªåŠ¨é‡è¿ |
| è®¾å¤‡åˆ†é…ä¸å‡ | æ™ºèƒ½è°ƒåº¦,è´Ÿè½½å‡è¡¡ |

### ä¸Šçº¿å‡†å¤‡

**Phase 1 ä¸Šçº¿** (Week 2):
- âœ… åŸºç¡€æ¶æ„å°±ç»ª
- âœ… Redroid 100% å…¼å®¹
- âš ï¸ ä»…å†…éƒ¨æµ‹è¯•

**Phase 2A ä¸Šçº¿** (Week 4):
- âœ… ç‰©ç†è®¾å¤‡ 10-100 å°æ”¯æŒ
- âœ… SCRCPY æŠ•å±
- âš ï¸ Beta æµ‹è¯•

**Phase 2B ä¸Šçº¿** (Week 6):
- âœ… 1000+ å°ç‰©ç†è®¾å¤‡æ”¯æŒ
- âœ… åˆ†ç‰‡ç®¡ç†,æ™ºèƒ½è°ƒåº¦
- âœ… æ­£å¼ä¸Šçº¿

**Phase 3/4 ä¸Šçº¿** (Week 10):
- âœ… åä¸º + é˜¿é‡Œäº‘æ‰‹æœºæ”¯æŒ
- âœ… å¤šäº‘å®¹ç¾
- âœ… å…¨çƒæœåŠ¡

---

## â“ å¾…ç¡®è®¤é—®é¢˜

**è¯·å°½å¿«ç¡®è®¤ä»¥ä¸‹ä¿¡æ¯**:

1. **â° ä¸Šçº¿æ—¶é—´è¦æ±‚**:
   - ç¬¬ä¸€ç‰ˆ (ç‰©ç†è®¾å¤‡åŸºç¡€ç‰ˆ) ä½•æ—¶ä¸Šçº¿?
   - å®Œæ•´ç‰ˆ (å››ç§è®¾å¤‡æº) ä½•æ—¶ä¸Šçº¿?

2. **ğŸ“ ç‰©ç†è®¾å¤‡ç½‘ç»œæ‹“æ‰‘**:
   - 1000+ å°è®¾å¤‡åœ¨åŒä¸€å±€åŸŸç½‘å—?
   - è¿˜æ˜¯åˆ†å¸ƒåœ¨å¤šä¸ªæœºæˆ¿/åœ°åŸŸ?
   - ç½‘ç»œå¸¦å®½å’Œå»¶è¿Ÿæƒ…å†µ?

3. **ğŸ·ï¸ è®¾å¤‡åˆ†ç»„éœ€æ±‚**:
   - æ˜¯å¦éœ€è¦æŒ‰å‹å·ã€Android ç‰ˆæœ¬ã€åœ°åŸŸåˆ†ç»„?
   - ç”¨æˆ·æ˜¯å¦å¯ä»¥æŒ‡å®šè®¾å¤‡?

4. **ğŸ”§ ç°æœ‰åŸºç¡€è®¾æ–½**:
   - ç‰©ç†è®¾å¤‡æ˜¯å¦å·²é…ç½®ç½‘ç»œ ADB?
   - æ˜¯å¦æœ‰ç°æˆçš„è®¾å¤‡ç®¡ç†ç³»ç»Ÿ?
   - æ˜¯å¦éœ€è¦æˆ‘ä»¬æä¾›è®¾å¤‡æ¥å…¥æŒ‡å—?

5. **â˜ï¸ äº‘æ‰‹æœºä½¿ç”¨åœºæ™¯**:
   - åä¸ºå’Œé˜¿é‡Œäº‘ä¸»è¦ç”¨äºå“ªäº›åœºæ™¯?
   - é¢„æœŸå¹¶å‘æ•°?
   - æˆæœ¬é¢„ç®—?

---

## ğŸ“ ä¸‹ä¸€æ­¥è¡ŒåŠ¨

**ç¡®è®¤åç«‹å³å¼€å§‹**:

1. æ ¹æ®ä½ çš„åé¦ˆè°ƒæ•´æ–¹æ¡ˆç»†èŠ‚
2. ç¡®å®š Phase 1 å®æ–½æ—¶é—´è¡¨
3. ç»§ç»­ Phase 1 ä»£ç å®ç°:
   - æ•°æ®åº“è¿ç§»
   - Redroid Provider å°è£…
   - DevicesService é‡æ„

**å½“å‰çŠ¶æ€**: ç­‰å¾…éœ€æ±‚ç¡®è®¤

**å·²å®Œæˆ**:
- âœ… Phase 1.1 æ ¸å¿ƒæ¥å£å®šä¹‰ (100%)
- âœ… æ–¹æ¡ˆæ–‡æ¡£å®Œæˆ

**ç­‰å¾…ä½ çš„å›å¤! ğŸš€**
